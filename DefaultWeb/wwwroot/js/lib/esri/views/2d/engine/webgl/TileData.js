//>>built
define("require exports ../../../../core/ObjectPool ./TileDisplayData ./TileBufferData ./WGLDisplayRecord ./enums".split(" "),function(u,v,t,m,p,n,e){return function(){function f(){this.tileBufferData=this.tileDisplayData=null}return f.prototype.release=function(){m.pool.release(this.tileDisplayData);this.tileDisplayData=null;p.pool.release(this.tileBufferData);this.tileBufferData=null},f.prototype.serialize=function(){var b=this.tileBufferData.serialize(),c=this.tileBufferData.getBuffers(),a=m.serialize(this.tileDisplayData,
null,0),a=new Uint8Array(a);m.serialize(this.tileDisplayData,a,0);c.push(a.buffer);return{data:{displayData:a.buffer,bufferData:b},buffers:c}},f.deserialize=function(b){var c=m.pool.acquire();m.deserialize(c,new Uint8Array(b.displayData),0);b=p.deserialize(b.bufferData);var a=new f;return a.tileDisplayData=c,a.tileBufferData=b,a},f.prototype.deserializeMeshData=function(){var b=this;this.tileDisplayData.displayObjectRegistry.forEach(function(c,a){c=0;for(a=b.tileDisplayData.displayObjectRegistry.get(a).displayRecords;c<
a.length;c++){var d=a[c],e=d.geometryType;d.readMeshDataFromBuffers(b.tileBufferData.geometries[e].vertexBuffer,b.tileBufferData.geometries[e].indexBuffer)}})},f.bind=function(b,c){var a=new f;return a.tileDisplayData=b,a.tileBufferData=c,a},f.create=function(b,c){var a=new f;a.tileDisplayData=new m;for(var d=[0,0,0,0],q=[0,0,0,0],k=0;k<b.length;k++){var l=b[k];a.tileDisplayData.displayObjects.push(l);a.tileDisplayData.displayObjectRegistry.set(l.id,l);for(var g=0,l=l.displayRecords;g<l.length;g++){var h=
l[g];a.tileDisplayData.displayRecords[h.geometryType].push(h);d[h.geometryType]+=h.meshData.vertexCount;q[h.geometryType]+=h.meshData.indexData.length}}k=function(a,b){return a.sortKey-b.sortKey};for(b=0;b<a.tileDisplayData.displayRecords.length;b++)a.tileDisplayData.displayRecords[b].sort(k);k=[c.fill||{},c.line||{},c.icon||{},c.text||{}];g=new p;for(b=0;4>b;b++){g.geometries[b].indexBuffer=new Uint32Array(q[b]);g.geometries[b].vertexBuffer={};c=k[b];for(var r in c)g.geometries[b].vertexBuffer[r]=
{data:new Uint32Array(d[b]*c[r]/4),stride:c[r]}}a.tileBufferData=g;(d=a.tileBufferData.geometries[e.WGLGeometryType.FILL])&&n.writeAllMeshDataToBuffers(a.tileDisplayData.displayRecords[e.WGLGeometryType.FILL],d.vertexBuffer,d.indexBuffer);(d=a.tileBufferData.geometries[e.WGLGeometryType.LINE])&&n.writeAllMeshDataToBuffers(a.tileDisplayData.displayRecords[e.WGLGeometryType.LINE],d.vertexBuffer,d.indexBuffer);(d=a.tileBufferData.geometries[e.WGLGeometryType.MARKER])&&n.writeAllMeshDataToBuffers(a.tileDisplayData.displayRecords[e.WGLGeometryType.MARKER],
d.vertexBuffer,d.indexBuffer);d=a.tileBufferData.geometries[e.WGLGeometryType.TEXT];return d&&n.writeAllMeshDataToBuffers(a.tileDisplayData.displayRecords[e.WGLGeometryType.TEXT],d.vertexBuffer,d.indexBuffer),a.tileDisplayData.displayList.addToList(a.tileDisplayData.displayRecords[e.WGLGeometryType.FILL]),a.tileDisplayData.displayList.addToList(a.tileDisplayData.displayRecords[e.WGLGeometryType.LINE]),a.tileDisplayData.displayList.addToList(a.tileDisplayData.displayRecords[e.WGLGeometryType.MARKER]),
a.tileDisplayData.displayList.addToList(a.tileDisplayData.displayRecords[e.WGLGeometryType.TEXT]),a},f.pool=new t(f),f}()});