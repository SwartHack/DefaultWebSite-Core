//>>built
define(["require","exports"],function(x,m){function u(a,c,b,d,e,f,h){switch(b){case 1:for(b=0;h>b;b++)d[e]=a[c],c+=1,e+=f;break;case 2:for(b=0;h>b;b++)d[e]=a[c],d[e+1]=a[c+1],c+=2,e+=f;break;case 3:for(b=0;h>b;b++)d[e]=a[c],d[e+1]=a[c+1],d[e+2]=a[c+2],c+=3,e+=f;break;case 4:for(b=0;h>b;b++)d[e]=a[c],d[e+1]=a[c+1],d[e+2]=a[c+2],d[e+3]=a[c+3],c+=4,e+=f;break;default:throw k("Unhandled stride size "+b);}}function v(a,c,b,d,e,f){switch(c){case 1:for(c=0;f>c;c++)b[d]=a[0],d+=e;break;case 2:for(c=0;f>c;c++)b[d]=
a[0],b[d+1]=a[0],d+=e;break;case 3:for(c=0;f>c;c++)b[d]=a[0],b[d+1]=a[0],b[d+2]=a[0],d+=e;break;case 4:for(c=0;f>c;c++)b[d]=a[0],b[d+1]=a[0],b[d+2]=a[0],b[d+3]=a[0],d+=e;break;default:throw k("Unhandled stride size "+c);}}function w(a){switch(a){case 5120:return Int8Array;case 5126:return Float32Array;case 5124:return Int32Array;case 5122:return Int16Array;case 5121:return Uint8Array;case 5125:return Uint32Array;case 5123:return Uint16Array}throw Error("Unhandled data type: "+a);}function t(a){switch(a){case 5120:return"Int8";
case 5126:return"Float32";case 5124:return"Int32";case 5122:return"Int16";case 5121:return"UInt8";case 5125:return"UInt32";case 5123:return"UInt16"}throw Error("Unhandled data type: "+a);}function q(a){return 0<a&&0===a%Uint32Array.BYTES_PER_ELEMENT}function k(a){return Error("I3SGeometryUtil processing failed: "+a)}Object.defineProperty(m,"__esModule",{value:!0});var r=new Uint8Array(64);m.interleaveGeometryBuffer=function(a,c,b,d){void 0===d&&(d=[]);var e=a.params.vertexAttributes,f=e.position.count;
if(!q(b[0].stride))throw k("Layout stride must use "+Uint32Array.BYTES_PER_ELEMENT+"-byte words");var h=new Uint32Array(b[0].stride/Uint32Array.BYTES_PER_ELEMENT*f);b=b.slice(0).sort(function(a,b){return a.offset-b.offset});a=function(a){var b=e[a.name],l=w(a.type),g=void 0,n=!1;if(null==b){n=d.filter(function(b){return b.name===a.name})[0];if(!n)throw k("Geometry definition is missing attribute");b={valueType:t(a.type),byteOffset:0,count:f,valuesPerElement:a.count};for(g=0;g<r.length;g++)r[g]=n.byteValue;
g=r.buffer;n=!0}else g=c;if(t(a.type)!==b.valueType)throw k("Geometry definition type must match attribute type");if(0!==b.byteOffset%Uint32Array.BYTES_PER_ELEMENT||0!==a.offset%Uint32Array.BYTES_PER_ELEMENT)throw k(a.name+" offset must use "+Uint32Array.BYTES_PER_ELEMENT+"-byte words");if(!q(b.valuesPerElement*l.BYTES_PER_ELEMENT)||!q(a.count*l.BYTES_PER_ELEMENT))throw k(a.name+" data must use "+Uint32Array.BYTES_PER_ELEMENT+"-byte words");var g=new Uint32Array(g),p=b.byteOffset/Uint32Array.BYTES_PER_ELEMENT,
b=b.valuesPerElement*l.BYTES_PER_ELEMENT/Uint32Array.BYTES_PER_ELEMENT,l=a.offset/Uint32Array.BYTES_PER_ELEMENT,m=a.stride/Uint32Array.BYTES_PER_ELEMENT;n?v(g,b,h,l,m,f):u(g,p,b,h,l,m,f)};for(var p=0;p<b.length;p++)a(b[p]);return h.buffer}});