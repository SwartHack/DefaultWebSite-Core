//>>built
require({cache:{"url:esri/views/3d/terrain/TerrainMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\n\n\x3csnippets\x3e\n\n\x3csnippet name\x3d"vsTerrain"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  uniform mat4 proj;\n  uniform mat4 view;\n  uniform vec3 origin;\n  uniform vec2 texOffset;\n  uniform float texScale;\n  uniform mat4 viewNormal;\n\n  attribute vec3 $position;\n  attribute vec2 $uv0;\n  varying vec2 vtc;\n  varying vec3 vpos;\n  varying vec3 vnormal;\n\n#ifdef RECEIVE_SHADOWS\n  varying float linearDepth;\n#endif\n\n#if defined(WIREFRAME) || defined(TILE_BORDERS)\n  varying vec2 vuv;\n#endif\n\n#ifdef ATMOSPHERE\n  uniform vec3 lightDirection;\n  varying vec3 wpos;\n  varying vec3 wview;\n  varying vec3 wnormal;\n  varying vec3 wlight;\n#endif\n\n#ifdef OVERLAY\n  uniform vec2 overlayTexOffset;\n  uniform vec2 overlayTexScale;\n  varying vec2 vtcOverlay;\n#endif\n\n#ifdef SCREEN_SIZE_PERSPECTIVE /* debug only */\n\n  uniform vec4 screenSizePerspective;\n\n  varying float screenSizeDistanceToCamera;\n  varying float screenSizeCosAngle;\n\n#endif\n\n  void main(void) {\n    vpos \x3d $position;\n\n#ifdef SPHERICAL\n    vnormal \x3d normalize(vpos + origin);\n#else\n    vnormal \x3d vec3(0, 0, 1); // WARNING: up-axis dependent code\n#endif\n\n#ifdef ATMOSPHERE\n    wpos \x3d (view * vec4(vpos, 1.0)).xyz;\n    wnormal \x3d (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n    wlight \x3d (view  * vec4(lightDirection, 1.0)).xyz;\n#endif\n\n#if defined(WIREFRAME) || defined(TILE_BORDERS)\n    vuv \x3d $uv0;\n#endif\n\n#ifdef SCREEN_SIZE_PERSPECTIVE /* debug only */\n\n    vec3 viewPos \x3d (view * vec4(vpos, 1.0)).xyz;\n\n    screenSizeDistanceToCamera \x3d length(viewPos);\n\n    vec3 viewSpaceNormal \x3d (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n    screenSizeCosAngle \x3d abs(viewSpaceNormal.z);\n\n#endif\n\n    gl_Position \x3d proj * view * vec4(vpos, 1.0);\n\n#ifdef RECEIVE_SHADOWS\n    // Shadowmap\'s cascading index used to be based on \'1.0 / gl_FragCoord.w\'\n    // (i.e. the perspective interpolation of \'gl_Position.w\'). Precision\n    // issues on iPad/iPhone with the \'w\' component require the depth to be\n    // passed as varying to properly drive the cascading shadow map index.\n    linearDepth \x3d gl_Position.w;\n#endif\n\n    vtc \x3d $uv0*texScale + texOffset;\n\n#ifdef OVERLAY\n    vtcOverlay \x3d $uv0*overlayTexScale + overlayTexOffset;\n#endif\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsTerrainCommon"\x3e\x3c![CDATA[\n  uniform vec3 lightDirection;\n  uniform vec3 viewDirection;\n  uniform sampler2D depthTex;\n  uniform int shadowMapNum;\n  uniform vec4 shadowMapDistance;\n  uniform mat4 shadowMapMatrix[4];\n  uniform float depthHalfPixelSz;\n  uniform sampler2D ssaoTex;\n  uniform vec4 viewportPixelSz;\n  uniform sampler2D tex;\n  uniform float opacity;\n\n  varying vec3 vpos;\n  varying vec3 vnormal;\n  varying vec2 vtc;\n\n#if defined(WIREFRAME) || defined(TILE_BORDERS)\n  varying vec2 vuv;\n#endif\n\n#ifdef ATMOSPHERE\n  varying vec3 wpos;\n  varying vec3 wview;\n  varying vec3 wnormal;\n  varying vec3 wlight;\n#endif\n\n  $sceneLightingDefinitions\n\n#ifdef SCREEN_SIZE_PERSPECTIVE /* debug only */\n  $screenSizePerspective\n\n  uniform vec4 screenSizePerspective;\n\n  varying float screenSizeDistanceToCamera;\n  varying float screenSizeCosAngle;\n#endif\n\n  const vec3 ambient \x3d vec3(0.2,0.2,0.2);\n  const vec3 diffuse \x3d vec3(0.8,0.8,0.8);\n  const float diffuseHardness \x3d 2.5;\n\n#ifdef OVERLAY\n  uniform sampler2D overlayTex;\n  uniform float overlayOpacity;\n  varying vec2 vtcOverlay;\n#endif\n\n#ifdef RECEIVE_SHADOWS\n\tvarying float linearDepth;\n\t$evalShadow\n#endif\n\n  float lum(vec3 c) {\n    float max \x3d max(max(c.r, c.g), c.b);\n    float min \x3d min(min(c.r, c.g), c.b);\n    return (min + max) * 0.5;\n  }\n\n#ifdef ATMOSPHERE\n  vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n    vec3 surfaceColor   \x3d vec3(0.0);\n    vec3 fuzzySpecColor \x3d vec3(1.0);\n    vec3 subColor       \x3d vec3(0.0);\n    float rollOff       \x3d 1.0;\n\n    vec3 Ln \x3d normalize(lightPos);\n    vec3 Nn \x3d normalize(normal);\n    vec3 Hn \x3d normalize(view + Ln);\n\n    float ldn \x3d dot(Ln, Nn);\n    float diffComp \x3d max(0.0, ldn);\n    float vdn \x3d 1.0 - dot(view, Nn);\n    float ndv \x3d dot(view, Ln);\n\n    vec3 diffContrib \x3d surfaceColor * diffComp;\n    float subLamb \x3d max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n\n    vec3 subContrib \x3d subLamb * subColor;\n    vec3 vecColor \x3d vec3(vdn);\n\n    vec3 diffuseContrib \x3d (subContrib + diffContrib);\n    vec3 specularContrib \x3d (vecColor * fuzzySpecColor);\n\n    return (diffContrib + specularContrib) * rollOff;\n  }\n#endif\n\n  void main() {\n    vec3 a \x3d ambient;\n\n    float shadow \x3d 0.0;\n#ifdef RECEIVE_SHADOWS\n    shadow \x3d evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\n#endif\n    float vndl \x3d dot(normalize(vnormal), lightDirection);\n    float k \x3d smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n    vec3 d \x3d (1.0 - shadow/1.8) * diffuse * k;\n\n    float ssao \x3d viewportPixelSz.w \x3c .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n    vec4 texCol \x3d texture2D(tex, vtc);\n\n#ifdef OVERLAY\n    if ((vtcOverlay.x \x3e 0.0) \x26\x26 (vtcOverlay.y \x3e 0.0) \x26\x26 (vtcOverlay.x \x3c 1.0) \x26\x26 (vtcOverlay.y \x3c 1.0)) {\n      vec4 overlayTexCol \x3d texture2D(overlayTex, vtcOverlay);\n      overlayTexCol *\x3d overlayOpacity;\n      texCol \x3d texCol * (1.0 - overlayTexCol.a) + overlayTexCol; // texCol and overlayTexCol have pre-multiplied alpha\n    }\n#endif\n\n    vec3 atm \x3d vec3(0.0);\n#ifdef ATMOSPHERE\n    float ndotl \x3d max(0.0, min(1.0, vndl));\n    atm \x3d atmosphere(wlight, wnormal, -viewDirection);\n    atm *\x3d max(0.0, min(1.0, (1.0-lum(texCol.rgb)*1.5))); //avoid atmosphere on bright base maps\n    atm *\x3d max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n#endif\n\n    vec3 albedo \x3d atm + texCol.rgb;\n    vec3 normal \x3d normalize(vnormal);\n\n    // heuristic shading function used in the old terrain, now used to add ambient lighting\n    float additionalAmbientScale \x3d smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n\t\tvec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n    gl_FragColor \x3d vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), texCol.a) * opacity;\n\n#ifdef SCREEN_SIZE_PERSPECTIVE /* debug only */\n    // This is only used for debug rendering the screenSize perspective\n\n    float perspectiveScale \x3d screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n\n    if (perspectiveScale \x3c\x3d 0.25) {\n      gl_FragColor \x3d mix(gl_FragColor, vec4(1, 0, 0, 1), perspectiveScale * 4.0);\n    }\n    else if (perspectiveScale \x3c\x3d 0.5) {\n      gl_FragColor \x3d mix(gl_FragColor, vec4(0, 0, 1, 1), (perspectiveScale - 0.25) * 4.0);\n    }\n    else if (perspectiveScale \x3e\x3d 0.99) {\n      gl_FragColor \x3d mix(gl_FragColor, vec4(0, 1, 0, 1), 0.2);\n    }\n    else {\n      gl_FragColor \x3d mix(gl_FragColor, vec4(1, 0, 1, 1), (perspectiveScale - 0.5) * 2.0);\n    }\n\n#endif\n\n  // closing } is missing here, it\'s in the shaders using this snippet below\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsTerrainWireframe"\x3e\x3c![CDATA[\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n  $fsprecisionf\n\n  struct WireframeSettings {\n    float width;\n    float falloff;\n    float subdivision;\n    vec4 color;\n    float wireOpacity;\n    float surfaceOpacity;\n  };\n\n  uniform WireframeSettings wireframe;\n\n    $fsTerrainCommon\n\n    vec2 vuvScaled \x3d vuv * wireframe.subdivision;\n    vec2 vuvMod \x3d fract(vuvScaled);\n\n#ifdef GL_OES_standard_derivatives\n    vec2 dVuv \x3d fwidth(vuvScaled);\n    dVuv \x3d max(vec2(0.00001), dVuv); // workaround against flickering skirts, see #10245\n#else\n    // Something that reasonably works\n    vec2 dVuv \x3d vec2(0.05);\n#endif\n\n    vec2 edgeFactors \x3d smoothstep((wireframe.width - wireframe.falloff) * dVuv,\n                                  wireframe.width * dVuv, min(vuvMod, 1.0 - vuvMod));\n\n    float edgeFactor \x3d 1.0 - min(edgeFactors.x, edgeFactors.y);\n\n#ifdef WIREFRAME\n    gl_FragColor \x3d vec4(mix(gl_FragColor.rgb, wireframe.color.rgb, edgeFactor * wireframe.color.a),\n                        mix(wireframe.surfaceOpacity, wireframe.wireOpacity, edgeFactor));\n#endif\n\n\n#ifdef TILE_BORDERS\n    dVuv \x3d fwidth(vuv);\n    edgeFactors \x3d smoothstep((wireframe.width - wireframe.falloff) * dVuv,\n                              wireframe.width * dVuv, min(vuv, 1.0 - vuv));\n    edgeFactor \x3d 1.0 - min(edgeFactors.x, edgeFactors.y);\n\n    gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);\n#endif\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsTerrain"\x3e\x3c![CDATA[\n    $fsprecisionf\n    $fsTerrainCommon\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsTerrainNormal"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  uniform vec3 origin;\n  uniform mat4 proj;\n  uniform mat4 view;\n  uniform mat4 viewNormal;\n  attribute vec3 $position;\n  varying vec3 vnormal;\n\n  void main(void) {\n#ifdef SPHERICAL\n    vec4 normal \x3d vec4(normalize($position + origin), 1.0);\n#else\n    vec4 normal \x3d vec4(0.0, 1.0, 0.0, 1.0);\n#endif\n\n    gl_Position \x3d proj * view * vec4($position, 1.0);\n    vnormal \x3d normalize((viewNormal * normal).xyz);\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsTerrainDepthOnly"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  uniform mat4 proj;\n  uniform mat4 view;\n\n  attribute vec3 $position;\n\n  void main() {\n    gl_Position \x3d proj * view * vec4($position, 1.0);\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsTerrainDepthOnly"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n  void main() {\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsTerrainHighlight"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  uniform mat4 proj;\n  uniform mat4 view;\n  uniform vec2 overlayTexScale;\n  uniform vec2 overlayTexOffset;\n\n  attribute vec3 $position;\n  attribute vec2 $uv0;\n\n  varying vec2 vtcOverlay;\n\n  void main() {\n    vtcOverlay \x3d $uv0*overlayTexScale + overlayTexOffset;\n\n    gl_Position \x3d proj * view * vec4($position, 1.0);\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsTerrainHighlight"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n  uniform sampler2D overlayTex;\n\n  uniform sampler2D depthTex;\n  uniform vec4 highlightViewportPixelSz;\n\n  varying vec2 vtcOverlay;\n\n  void main() {\n    vec4 texCol \x3d vec4(0,0,0,0);\n    if ((vtcOverlay.x \x3e 0.0) \x26\x26 (vtcOverlay.y \x3e 0.0) \x26\x26 (vtcOverlay.x \x3c 1.0) \x26\x26 (vtcOverlay.y \x3c 1.0)) {\n      texCol \x3d texture2D(overlayTex, vtcOverlay);\n    }\n\n    if (texCol.a \x3d\x3d 0.0) {\n      // Here we have to write black, instead of discarding the fragment in order to overwrite\n      // the highlights which might have been written by skirts of other tiles.\n      // As a consequence skirts are not visible, but terrain overwrites draped highlights.\n      gl_FragColor \x3d vec4(0,0,0,0);\n      return;\n    }\n\n    $highlightWrite\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3c/snippets\x3e\n'}});
define("dojo/when ./tileUtils ./TerrainConst ./TileGeometryFactory ./TileRenderData ./ResourceCounter ./TileRenderer ../support/PreallocArray ../../../core/ObjectPool ../../../core/promiseUtils ../support/imageUtils ../webgl-engine/lib/ShaderVariations dojo/text!./TerrainMaterial.xml ../webgl-engine/materials/internal/MaterialUtil ../webgl-engine/lib/Util ../lib/glMatrix ../webgl-engine/lib/RenderPass ../webgl-engine/lib/RenderSlot ../webgl-engine/lib/tracer ../../webgl/Texture ../../webgl/VertexArrayObject ../../webgl/BufferObject ../../webgl/Program ../webgl-engine/lib/DefaultVertexAttributeLocations ../webgl-engine/lib/DefaultVertexBufferLayouts ../webgl-engine/lib/screenSizePerspectiveUtils ../../webgl/Util".split(" "),
function(Ga,H,ga,ha,ia,Ha,Ia,N,ja,Ja,Ka,ka,La,O,C,m,I,J,T,Ma,Na,la,ma,U,Oa,Pa,na){var oa=C.assert;C=m.vec2d;var p=m.vec3d,pa=m.vec4d,Qa=m.mat4d.identity(),Ra=[2,2],qa=J.OPAQUE_TERRAIN,ra=J.TRANSPARENT_TERRAIN,sa=p.create(),V=C.create();m=function(m,B,C){function J(a,b){a=a.screenDepth;b=b.screenDepth;return b>a?-D:a>b?D:0}function Sa(a,b){return 0===a.tiles.length?-D:0===b.tiles.length?D:J(a.tiles.data[0],b.tiles.data[0])}B=B||256;var ta,e,g,ua=!1,t=null,W=null,v=null,va={},wa=new ja(ia),q=new N(10,
function(){return{root:null,tiles:new N(300)}}),X=!0,z=new H.IteratorPreorder,K=null,xa=!0,E=1,P=!0,Q=!1,f={mode:"none",width:1.5,falloff:1.5,wireOpacity:1,surfaceOpacity:0,color:[1,1,1,0],resolution:64},F=!1,ya=!1,Y=!1,D=1,Z=!0,aa=!0,G=null,k=null,w=null,R=!1,ba=[];this.updateTileBackground=function(a){return w&&w.cancel(),w=a?Ka.requestImage(a).otherwise(function(){return null}):Ja.resolve(null),this.renderTileBackground(),w};var ca=0,L=0,da=0,ea=0;this.resourceCounter=new Ha;this.castShadows=!0;
this.clippingExtent=null;this.loaded=function(){};var za=!1;this.needsRender=!0;this.receiveShadows=this.needsHighlight=this.didRender=!1;var x=new N(10),M=0,S=new N(30),Aa=new ja(function(){this.extent=pa.create();this.maxLevel=this.minLevel=0;this.callback=null},!1);this.renderTileBackground=function(){return e&&w&&k?w.then(function(a){k&&(R=!0,k.setGridImage(a),t&&H.traverseTilesPreorder(t,function(a){k.updateTileTexture(a)}.bind(this)))}.bind(this)):void 0};this.initializeRenderContext=function(a){e=
a.rctx;g=a.rctx.gl;var b=function(a){Ga(a).then(function(){ua=!0;this.setNeedsRender()}.bind(this)).otherwise(b)}.bind(this);b(this.renderTileBackground());ta=a.textureRep;var c=a.shaderSnippets,d=a.shaderRep;a=a.programRep;c.vsTerrain||c._parse(La);e.extensions.standardDerivatives;var n=new ka("terrain",["vsTerrain","fsTerrain"],null,a,d,c,e);n.addDefine("Spherical","SPHERICAL");n.addDefine("Overlay","OVERLAY");n.addDefine("Atmosphere","ATMOSPHERE");n.addDefine("Wireframe","WIREFRAME");n.addDefine("TileBorders",
"TILE_BORDERS");n.addBinaryShaderSnippetSuffix("Wireframe","Wireframe",[!1,!0]);n.addDefine("ReceiveShadows","RECEIVE_SHADOWS");n.addDefine("ScreenSizePerspective","SCREEN_SIZE_PERSPECTIVE");d=new ka("terrainNormal",["vsTerrainNormal","fsNormal"],null,a,d,c,e);d.addDefine("Spherical","SPHERICAL");d.addDefine("AlphaZero","ALPHA_ZERO");v={depth:a.get("depth"),depthShadowMap:a.get("depthShadowMap"),depthOnly:new ma(e,c.vsTerrainDepthOnly,c.fsTerrainDepthOnly,U.Default3D),highlight:new ma(e,c.vsTerrainHighlight,
c.fsTerrainHighlight,U.Default3D)};W={color:n,normal:d};this._updatePrograms();k=new Ia(e,B,a,this.resourceCounter,this.setNeedsRender.bind(this));this.renderTileBackground();G=new Ma(e,{target:g.TEXTURE_2D,pixelFormat:g.RGBA,dataType:g.UNSIGNED_BYTE,samplingMode:g.NEAREST,width:4,height:4})};this.uninitializeRenderContext=function(a){null!=G&&(G.dispose(),G=null);k&&(k.dispose(),k=null)};this._updatePrograms=function(){var a="spherical"===m,b="shader"===f.mode;v.color=W.color.getProgram([a,!0,a&&
aa,b,F,b||F,this.receiveShadows,Q]);v.normal=W.normal.getProgram([a,!0]);this.setNeedsRender()};this.destroy=function(a){this.uninstall(a);w&&(w.cancel(),w=null)};this.install=function(a){a.addExternalRenderer([qa,ra],this)};this.uninstall=function(a){a.removeExternalRenderer(this)};this.setRootTiles=function(a){t=a;this.setNeedsRender()};this.setNeedsHighlight=function(a){this.needsHighlight=a;this.setNeedsRender()};this.setStencilEnabledLayerExtents=function(a){ba=a;this.setNeedsRender()};this.setTileSize=
function(a){B=a;k&&(k.tileSize=a);this.setNeedsRender()};this.loadTile=function(a){oa(null===a.renderData);a.renderData=wa.acquire();a.renderData.init();var b=this.getLocalOriginOfTile(a),c=a.createGeometry(a.renderData.updateGeometryState(a),b,"debug"===f.mode,a.renderData.geometryInfo);a.renderData.localOrigin=b;this._setTileGeometry(a,c);R&&k.updateTileTexture(a)};this.queryVisibleLevelRange=function(a,b,c,d){var e=Aa.acquire();pa.set(a,e.extent);b?e.minLevel=b:e.minLevel=-Number.MAX_VALUE;null!=
c?e.maxLevel=c:e.maxLevel=Number.MAX_VALUE;e.callback=d;S.push(e);this.setNeedsRender()};this.updateTileTexture=function(a){k&&R&&k.updateTileTexture(a)};this.updateTileGeometryNeedsUpdate=function(a){return a.renderData.updateGeometryState(a).needsUpdate};this._updateTileGeometry=function(a){for(var b=a.renderData.geometryState,c=a.layerInfo[ga.LayerClass.ELEVATION],d=0;d<c.length;d++)c[d].pendingUpdates&=~ga.TileUpdateTypes.UPDATE_GEOMETRY;return b.needsUpdate?(a.renderData.vao&&this._releaseTileGeometry(a),
b=a.createGeometry(b,a.renderData.localOrigin,"debug"===f.mode,a.renderData.geometryInfo),this._setTileGeometry(a,b),!0):!1};this.updateTileGeometry=function(a){return a.renderData.updateGeometryState(a),this._updateTileGeometry(a)};this.unloadTile=function(a){this._releaseTileGeometry(a);a.renderData.texture&&a.renderData.texture.dispose();wa.release(a.renderData);a.renderData=null};this.getLocalOriginOfTile=function(a){if(10<=a.lij[0]){for(;7<a.lij[0];)a=a.parent;return a.centerAtSeaLevel}if("spherical"===
m)return sa;for(;a.parent;)a=a.parent;return a.centerAtSeaLevel};this.setVisibility=function(a){xa=a;this.setNeedsRender()};this.getStats=function(){return{numTilesRendered:L,numTilesCulled:da,numTrianglesRendered:ca,numOriginsRendered:ea}};this.setDisableRendering=function(a){ya=!!a;this.setNeedsRender()};this.getOpacity=function(){return E};this.getWireframeEnabled=function(){return"shader"===f.mode};this.setDebugScreenSizePerspective=function(a){a!==Q&&(Q=a,this._updatePrograms())};this.setWireframe=
function(a){if(a&&!0!==a||(a={mode:a?"shader":"none"}),void 0!==a.mode&&f.mode!==a.mode){var b="debug"===f.mode,c="debug"===a.mode;f.mode=a.mode;this._updatePrograms();b!==c&&t&&H.traverseTilesPreorder(t,function(a){if(a.renderData){a.renderData.vao&&this._releaseTileGeometry(a);var b=a.createGeometry(a.renderData.updateGeometryState(a),a.renderData.localOrigin,c,a.renderData.geometryInfo);this._setTileGeometry(a,b)}}.bind(this))}for(var d in a)f.hasOwnProperty(d)&&(f[d]=a[d]),this.setNeedsRender();
f.resolution&&(f.resolution=Math.min(f.resolution,B),f.resolution=1<<Math.round(Math.log(f.resolution)/Math.LN2))};this.setOpacity=function(a){E=a;this.setNeedsRender()};this.setDrawSkirts=function(a){P=a;this.setNeedsRender()};this.setCullBackFaces=function(a){Y=a;this.setNeedsRender()};this.setRenderOrder=function(a){D=a;this.setNeedsRender()};this.setBorders=function(a){F!==a&&(F=a,this._updatePrograms())};this.setFrontMostTransparent=function(a){Z!==a&&(Z=a,this.setNeedsRender())};this.setVelvetOverground=
function(a){aa!==a&&(aa=a,this._updatePrograms())};this.setNeedsRender=function(){this.needsRender=!0;this.didRender=!1;X=!0};this.resetNeedsRender=function(){this.didRender&&(this.needsRender=0!==S.length,this.didRender=!1)};var fa=p.create();this.isTransparent=function(){return 1>E||"shader"===f.mode&&(1>f.wireOpacity||1>f.surfaceOpacity)};this._renderMaterialPass=function(a,b){var c=this.isTransparent(),d=a.shadowMap&&a.shadowMap.getEnableState();this.receiveShadows!=d&&(this.receiveShadows=d,
this._updatePrograms());d=a.camera;(e.setDepthTestEnabled(!0),e.setBlendingEnabled(c),c&&e.setBlendFunctionSeparate(g.SRC_ALPHA,g.ONE_MINUS_SRC_ALPHA,g.ONE,g.ONE_MINUS_SRC_ALPHA),c&&Z)?(c=v.depthOnly,e.bindProgram(c),e.setColorMask(!1,!1,!1,!1),e.setDepthWriteEnabled(!0),this._renderTilesAuxiliary(a,c,b),e.setColorMask(!0,!0,!0,!0),e.setDepthFunction(g.EQUAL),e.setDepthWriteEnabled(!1)):e.setDepthFunction(g.LESS);c=v.color;e.bindProgram(c);c.setUniform1f("opacity",E);("shader"===f.mode||F)&&(c.setUniform1f("wireframe.width",
f.width),c.setUniform1f("wireframe.falloff",Math.min(f.width,f.falloff)),c.setUniform1f("wireframe.wireOpacity",f.wireOpacity*E),c.setUniform1f("wireframe.surfaceOpacity",f.surfaceOpacity*E),c.setUniform4fv("wireframe.color",f.color));d=a.camera;a.shadowMap&&a.shadowMap.bind(c);a.ssaoHelper&&a.ssaoHelper.setUniforms(c);c.setUniform1i("tex",4);c.setUniform1i("overlayTex",5);c.setUniformMatrix4fv("viewNormal",d.viewInverseTransposeMatrix);c.setUniformMatrix4fv("proj",d.projectionMatrix);a.lightingData.helper.setUniforms(c,
!0);d=d.viewMatrix;p.set3(d[12],d[13],d[14],fa);p.normalize(fa);c.setUniform3fv("viewDirection",fa);for(ea=ca=da=L=0;x.length<x.data.length&&0<S.length;)d=S.pop(),x.push(d);M=x.length;this._renderTiles(a,c,b);e.setBlendingEnabled(!1);e.setDepthFunction(g.LESS);e.setDepthWriteEnabled(!0);for(a=0;a<x.length;a++)b=x.data[a],Aa.release(b),b.callback(a>=M),b.callback=null;x.clear();0<L&&!za&&(za=!0,this.loaded&&this.loaded())};this._renderDepthPass=function(a,b,c){var d=a.camera;e.bindProgram(b);e.setBlendingEnabled(!1);
e.setDepthTestEnabled(!0);e.setDepthFunction(g.LESS);b.setUniformMatrix4fv("model",Qa);b.setUniformMatrix4fv("viewNormal",d.viewInverseTransposeMatrix);V[0]=d.near;V[1]=d.far;b.setUniform2fv("nearFar",V);this._renderTilesAuxiliary(a,b,c)};this._renderNormalPass=function(a,b){var c=a.camera,d=v.normal;e.bindProgram(d);e.setBlendingEnabled(!1);e.setDepthTestEnabled(!0);e.setDepthFunction(g.LESS);d.setUniformMatrix4fv("viewNormal",c.viewInverseTransposeMatrix);this._renderTilesAuxiliary(a,d,b)};this._renderHighlightPass=
function(a,b){var c=v.highlight;e.bindProgram(c);e.setBlendingEnabled(!1);e.setDepthTestEnabled(!0);e.setDepthFunction(g.LESS);var d=a.offscreenRenderingHelper;e.bindTexture(d.getDepthTexture(),6);c.setUniform1i("depthTex",6);c.setUniform4f("highlightViewportPixelSz",0,0,1/d.width,1/d.height);this._renderTilesAuxiliary(a,c,b,!0)};this.render=function(a){if(ua&&!ya&&xa&&t&&R){var b=this.isTransparent()?ra:qa;if(a.slot===b){T.trace("# BEGIN RENDER TERRAIN");b=a.pass;e.setFaceCullingEnabled(Y);var c=
1===a.lightingData.helper.globalFactor;b===I.MATERIAL?this._renderMaterialPass(a,this._updatePerOriginTileData()):b===I.MATERIAL_DEPTH_SHADOWMAP&&this.castShadows&&c?this._renderDepthPass(a,v.depthShadowMap,this._updatePerOriginTileData()):b===I.MATERIAL_DEPTH?this._renderDepthPass(a,v.depth,this._updatePerOriginTileData()):b===I.MATERIAL_NORMAL?this._renderNormalPass(a,this._updatePerOriginTileData()):b===I.MATERIAL_HIGHLIGHT&&this.needsHighlight&&(this._renderHighlightPass(a,this._updatePerOriginTileData()),
e.clear(e.gl.DEPTH_BUFFER_BIT));return Y&&e.setFaceCullingEnabled(!1),T.trace("# END RENDER TERRAIN"),!0}}};this._updatePerOriginTileData=function(){if(!X)return q;if(K=null,this._renderCollectOrigins(),0!==D){for(var a=0;a<q.length;a++)this._sortFrontToBack(q.data[a].tiles,J);this._sortFrontToBack(q,Sa)}return X=!1,q};this._renderCollectOrigins=function(){q.clear();for(var a=0;a<t.length;a++){var b=t[a],c=q.next();c.root=b;"spherical"===m?c.origin=sa:c.origin=b.centerAtSeaLevel;c.tiles.clear();this._renderCollectOriginsForRoot(c)}return!0};
this._renderCollectOriginsForRoot=function(a){for(z.reset(a.root);!z.done;){var b=z.next(),c=b.renderData;if(!c||b.visible){var d=q.peek();if(7===b.lij[0]&&((d===a||0!==d.tiles.length)&&(d=q.next(),d.tiles.clear()),d.root=b,d.origin=b.centerAtSeaLevel),c)10<=b.lij[0]?q.peek().tiles.push(b):a.tiles.push(b),(!K||b.vlevel>K.vlevel)&&(K=b),z.skip()}else da++,z.skip()}};this._sortFrontToBack=function(a,b){a.sort(b)};this._updateStencilReadStateForTile=function(a,b){if(a.stencilRenderingHelper&&a.stencilRenderingHelper.getEnableState()){for(var c=
!1,d=0;d<ba.length;d++)if(b.intersectsExtent(ba[d])){c=!0;break}c?a.stencilRenderingHelper.enableStencilRead():a.stencilRenderingHelper.disableStencilRead()}};this._renderTilesAuxiliary=function(a,b,c,d){var e=a.camera,f=e.viewMatrix,h=a.rctx;b.setUniformMatrix4fv("proj",e.projectionMatrix);d&&b.setUniform1i("overlayTex",5);for(e=0;e<c.length;e++){var k=c.data[e];b.setUniform3fv("origin",k.origin);O.bindView(k.origin,f,b);for(var m=0;m<k.tiles.length;m++){var y=k.tiles.data[m],r=y.renderData;d&&(r.highlightOverlayTexId?
Ba(b,r,r.highlightOverlayTexId):h.bindTexture(G,5));this._updateStencilReadStateForTile(a,y);h.bindVAO(r.vao);na.assertCompatibleVertexAttributeLocations(r.vao,b);y=r.vao.indexBuffer.size;P||(y=r.geometryInfo.numWithoutSkirtIndices);h.drawElements(g.TRIANGLES,y,r.vao.indexBuffer.indexType,0)}}h.bindVAO(null);h.stencilRenderingHelper&&h.stencilRenderingHelper.disableStencilRead()};this._renderTiles=function(a,b,c){var d=a.camera.viewMatrix;if(Q){var n=Pa.getSettings(m);n.update({distance:C.distanceToSurface,
fovY:C.fovY});O.bindScreenSizePerspective(n,b,"screenSizePerspective")}for(n=0;n<c.length;n++){var l=c.data[n];b.setUniform3fv("origin",l.origin);O.bindView(l.origin,d,b);a.shadowMap&&a.shadowMap.bindView(b,l.origin);ea++;var h=l.tiles;if(0!==h.length){var k=g.TRIANGLES;"debug"===f.mode&&(k=g.LINES);var p,y,r=K;r?(p=r.vlevel,y=B/f.resolution):(p=16,y=B/64);for(r=0;r<h.length;r++){var u=h.data[r],l=u.renderData;this._updateStencilReadStateForTile(a,u);T.trace("# RENDER TILE "+u.lij[0]+"/"+u.lij[1]+
"/"+u.lij[2]+", screenDepth:"+u.screenDepth);b.setUniform2fv("texOffset",l.texOffset);b.setUniform1f("texScale",l.texScale);(e.bindTexture(l.textureReference||l.texture,4),l.overlayTexId?Ba(b,l,l.overlayTexId):(b.setUniform2fv("overlayTexOffset",Ra),e.bindTexture(G,5)),"shader"===f.mode||F)&&b.setUniform1f("wireframe.subdivision",y*(1<<p-u.vlevel));var A=l.vao.indexBuffer.size;P||(A=l.geometryInfo.numWithoutSkirtIndices);e.bindVAO(l.vao);na.assertCompatibleVertexAttributeLocations(l.vao,b);e.drawElements(k,
A,l.vao.indexBuffer.indexType,0);u.renderOrder=L;L++;ca+=A/3;l=u.extent;u=u.lij[0];for(A=0;M>A;){var t=x.data[A],q=t.extent;u>=t.minLevel&&u<=t.maxLevel&&q[0]<=l[2]&&q[2]>=l[0]&&q[1]<=l[3]&&q[3]>=l[1]?(x.swap(A,M-1),M--):A++}}}}e.bindVAO(null);a.stencilRenderingHelper&&a.stencilRenderingHelper.disableStencilRead()};var Ba=function(a,b,c){var d=va[c];d||(d=ta.aquire(c).getGLTexture(),oa(d),va[c]=d);a.setUniform2fv("overlayTexOffset",b.overlayTexOffset);a.setUniform2fv("overlayTexScale",b.overlayTexScale);
a.setUniform1f("overlayOpacity",b.overlayOpacity);e.bindTexture(d,5)},Ca=p.create(),Da=p.create(),Ea=p.create(),Fa=this.clippingExtent;this.intersect=function(a,b,c){if(t&&(!a.isSelection||!this.isTransparent())&&a.enableTerrain){p.subtract(c,b,Ca);var d=a.getMinResult(),e=a.getMaxResult();z.reset(t);for(var f={};!z.done;){var h=z.next();if(null!==h.renderData){if(a.enableInvisibleTerrain){if(!h.visible&&Fa&&!h.intersectsExtent(Fa))continue}else if(!h.visible)continue;var k=h.renderData.geometryInfo.geometry,
g=h.renderData.localOrigin;p.subtract(b,g,Da);p.subtract(c,g,Ea);O.intersectTriangleGeometry(k,f,void 0,a,Da,Ea,function(b,c,f){if((P||!(3*f>=h.renderData.geometryInfo.numWithoutSkirtIndices))&&0<=b&&(a.enableBackfacesTerrain||0>p.dot(c,Ca))){var g;(void 0===d.dist||b<d.dist)&&(g=H.lij2str(h.lij[0],h.lij[1],h.lij[2]),d.set(void 0,g,b,c,void 0),d.setIntersector("terrain"));(void 0===e.dist||b>e.dist)&&(g=H.lij2str(h.lij[0],h.lij[1],h.lij[2]),e.set(void 0,g,b,c,void 0),e.setIntersector("terrain"))}})}}}};
this._setTileGeometry=function(a,b){a=a.renderData;var c=b.geometry.getData(),d=c.getVertexAttr().terrain.data,c=c.indices.terrain;a.vao=new Na(e,U.Default3D,{geometry:Oa.Pos3Tex},{geometry:la.createVertex(e,g.STATIC_DRAW,d)},la.createIndex(e,g.STATIC_DRAW,c));a.geometryInfo.geometry&&ha.releaseGeometry(a.geometryInfo.geometry);a.geometryInfo=b;this.setNeedsRender()};this._releaseTileGeometry=function(a){a=a.renderData;a.vao.dispose(!0);a.vao=null;a.geometryInfo.geometry&&ha.releaseGeometry(a.geometryInfo.geometry);
a.geometryInfo.geometry=null;this.setNeedsRender()}};return m.TileRenderData=ia,m});