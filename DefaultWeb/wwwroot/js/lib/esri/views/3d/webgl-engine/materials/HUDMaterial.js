//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/HUDMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\n\n\x3csnippets\x3e\n\n\x3csnippet name\x3d"vertexShaderHUD"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  $commonAttributesAndUniformsHUD\n\n  uniform float pixelRatio;\n  uniform vec2 screenOffset;\n  uniform vec2 anchorPos;\n\n#ifdef SCREEN_SIZE_PERSPECTIVE\n\n  uniform vec4 screenSizePerspective;\n\n#endif\n\n#ifdef DEBUG_DRAW_BORDER\n  varying vec3 debugBorderCoords;\n#endif\n\n  attribute vec2 $uv0;\n  attribute vec4 $color;\n  attribute vec2 $size;\n  attribute vec4 $auxpos2;\n\n  varying vec4 vcolor;\n\n  varying vec2 vtc;\n  varying vec2 vsize;\n\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\n  varying float voccluded;\n#endif\n\n  $vvUniforms\n\n  $alignToPixelCenter\n  $alignToPixelOrigin\n  $projectPositionHUD\n  $vvFunctions\n\n  void main(void) {\n    ProjectHUDAux projectAux;\n    vec4 posProj \x3d projectPositionHUD(projectAux);\n\n    vec2 inputSize;\n\n#ifdef SCREEN_SIZE_PERSPECTIVE\n\n    inputSize \x3d screenSizePerspectiveScaleVec2($size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n\n    vec2 screenOffsetScaled \x3d screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n\n#else\n\n    inputSize \x3d $size;\n\n    vec2 screenOffsetScaled \x3d screenOffset;\n#endif\n\n#ifdef VV_SIZE\n    // only use width (.xx) for proportional scaling\n    // (if no width was defined in vv, width\n    //  will be a copy of height vv)\n    inputSize *\x3d vvGetScale($auxpos2).xx;\n#endif\n\n    vec2 combinedSize \x3d inputSize * pixelRatio;\n    vec4 quadOffset \x3d vec4(0);\n\n#if defined(OCCL_TEST) || defined(BINARY_HIGHLIGHT_OCCLUSION)\n    bool visible \x3d testVisibilityHUD(posProj);\n#endif\n\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\n  voccluded \x3d visible ? 0.0 : 1.0;\n#endif\n\n#ifdef OCCL_TEST\n    if (visible) {\n#endif\n      // UV goes from 0 to 1.99999, where the integer part is used\n      // for the normalized vertex coordinates, and the fractional\n      // part is used for texture sampling\n      vec2 uv01 \x3d floor($uv0);\n      vec2 uv \x3d $uv0 - uv01;\n\n      // Displace icon based on anchor position (normalized for size) and\n      // absolute screen offset. anchorPos is [-0.5, 0.5]\n      quadOffset.xy \x3d ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;\n\n#ifdef SIGNED_DISTANCE_FIELD\n\n      // SDF primitives might be scaled so that the SDF texture resolution does\n      // not match the resolution of the canvas, but we still want to render\n      // outline-only (\'cross\' and \'x\') primitives cleanly. Aligning to a screen\n      // pixel border at the geometry center achieves this, since SDF textures\n      // always have power of 2 dimensions.\n      posProj \x3d alignToPixelOrigin(posProj, viewport.zw) + quadOffset;\n#else\n      posProj +\x3d quadOffset;\n\n      // Aligning vertex positions to the nearest (using \'floor\') screen pixel\n      // border renders textures with pixel-perfect results. If the texture\n      // resolution does not match the canvas resolution then aligning is\n      // redundant.\n      if (inputSize.x \x3d\x3d $size.x) {\n        posProj \x3d alignToPixelOrigin(posProj, viewport.zw);\n      }\n#endif\n\n      gl_Position \x3d posProj;\n\n      vtc \x3d uv;\n\n#ifdef DEBUG_DRAW_BORDER\n      debugBorderCoords \x3d vec3(uv01, 1.0 / combinedSize);\n#endif\n\n      vsize \x3d inputSize;\n#ifdef OCCL_TEST\n    } else {\n      vtc \x3d vec2(.0);\n\n#ifdef DEBUG_DRAW_BORDER\n      debugBorderCoords \x3d vec3(0);\n#endif\n\n    }\n#endif\n\n    gl_Position \x3d posProj;\n\n#ifdef VV_COLOR\n    vcolor \x3d vvGetColor($auxpos2, vvColorValues, vvColorColors);\n#else\n    vcolor \x3d $color / 255.0;\n#endif\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fragmentShaderHUDBaseVariables"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n  #extension GL_OES_standard_derivatives : require\n\n  uniform sampler2D tex;\n  uniform vec4 overrideColor;\n  uniform vec4 outlineColor;\n  uniform float outlineSize;\n\n  varying vec4 vcolor;\n\n  varying vec2 vtc;\n  varying vec2 vsize;\n\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\n  varying float voccluded;\n#endif\n\n#ifdef DEBUG_DRAW_BORDER\n  varying vec3 debugBorderCoords;\n#endif\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fragmentShaderHUDBaseMain"\x3e\x3c![CDATA[\n  vec4 premultiply(vec4 v) {\n    return vec4(v.rgb * v.a, v.a);\n  }\n\n  void main() {\n\n#ifdef SIGNED_DISTANCE_FIELD\n    vec4 color \x3d vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 fillPixelColor \x3d overrideColor * vcolor;\n\n    // Attempt to sample texel centers to avoid thin cross outline\n    // disappearing with large symbol sizes.\n    // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041\n    const float txSize \x3d 128.0;\n    vec2 scaleFactor \x3d ((vsize - txSize) / txSize);\n    vec2 samplePos \x3d vtc + vec2(1.0, -1.0) * (1.0 / txSize) * scaleFactor;\n\n    // Distance in [-0.5, 0.5]\n    float d \x3d dot(texture2D(tex, samplePos), vec4(1.0/16777216.0, 1.0/65535.0, 1.0/256.0, 1.0)) - 0.5;\n\n    // Work around loss of precision for \'d \x3d 0.0\'.\n    // \'0\' gets normalised to 0.5 * 256 \x3d 128 before float packing, but can only\n    // be stored in the texture as 128 / 255 \x3d 0.502.\n    // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603110\n    const float diff \x3d (128.0/255.0 - 0.5);\n\n    // adjust all values, not just those close to 0, to avoid discontinuities in\n    // the outlines of other shapes e.g. circles\n    d \x3d d - diff;\n\n    // Distance in output units\n    float dist \x3d d * vsize.x;\n\n    fillPixelColor.a *\x3d clamp(0.5 - dist, 0.0, 1.0);\n\n    if (outlineSize \x3e 0.25) {\n      vec4 outlinePixelColor \x3d outlineColor;\n      float clampedOutlineSize \x3d min(outlineSize, 0.5*vsize.x);\n      outlinePixelColor.a *\x3d clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\n\n      // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\n      float compositeAlpha \x3d outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n      vec3 compositeColor \x3d vec3(outlinePixelColor) * outlinePixelColor.a +\n        vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n\n      gl_FragColor \x3d vec4(compositeColor, compositeAlpha);\n    }\n    else {\n      gl_FragColor \x3d premultiply(fillPixelColor);\n    }\n\n    // visualize SDF:\n    // gl_FragColor \x3d vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\n#else\n\n    // HUDMaterial is rendered with a blending mode that assumes a pre-multiplied\n    // fragment color. Input textures should already be pre-multiplied and so\n    // don\'t require adjustment, but the override and vertex colors must be\n    // modulated by their alpha values.\n\n    gl_FragColor \x3d texture2D(tex, vtc, -0.5) * premultiply(overrideColor * vcolor);\n\n#endif\n\n#ifdef DEBUG_DRAW_BORDER\n     float isBorder \x3d float(any(lessThan(debugBorderCoords.xy, vec2(debugBorderCoords.z))) || any(greaterThan(debugBorderCoords.xy, vec2(1.0 - debugBorderCoords.z))));\n     gl_FragColor \x3d mix(gl_FragColor, vec4(1, 0, 1, 1), isBorder);\n#endif\n\n    if (gl_FragColor.a \x3c 0.1) {\n      discard;\n    }\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fragmentShaderHUD"\x3e\x3c![CDATA[\n$fragmentShaderHUDBaseVariables\n$fragmentShaderHUDBaseMain\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fragmentShaderHUDHighlight"\x3e\x3c![CDATA[\n$fragmentShaderHUDBaseVariables\n\n  uniform sampler2D depthTex;\n  uniform vec4 highlightViewportPixelSz;\n\n$fragmentShaderHUDBaseMain\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\n    // Instead of deciding on a per-pixel basis if the highlight is occluded,\n    // do it for all highlight pixel based on the centroid occlusion. This\n    // is a temporary solution for:\n    // https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/9645\n    if (voccluded \x3d\x3d 1.0) {\n      gl_FragColor \x3d vec4(1.0, 1.0, 0.0, 1.0);\n    } else {\n      gl_FragColor \x3d vec4(1.0, 0.0, 1.0, 1.0);\n    }\n#else\n    $highlightWrite\n#endif\n  }\n]]\x3e\x3c/snippet\x3e\n\n\n\x3csnippet name\x3d"vertexShaderOcclusionTestPixel"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n  $commonAttributesAndUniformsHUD\n\n  $alignToPixelCenter\n  $projectPositionHUD\n\n  void main(void) {\n    vec4 posProjCenter;\n\n    // Check for special value of position (0, 0, 0) which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just project outside\n    // of clip space.\n    if (dot($position, $position) \x3e 0.0) {\n      // Render single point to center of the pixel to avoid subpixel filtering to affect\n      // the marker color\n      ProjectHUDAux projectAux;\n      vec4 posProj \x3d projectPositionHUD(projectAux);\n\n      posProjCenter \x3d alignToPixelCenter(posProj, viewport.zw);\n    }\n    else {\n      // Project out of clip space\n      posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\n    }\n\n    gl_Position \x3d posProjCenter;\n    gl_PointSize \x3d 1.0;\n  }\n]]\x3e\x3c/snippet\x3e\n\n\x3c/snippets\x3e\n'}});
define("require exports ../../../../core/tsSupport/extendsHelper dojo/text!./HUDMaterial.xml ./internal/MaterialUtil ../lib/Util ../../../webgl/Util ./internal/MaterialBase ./internal/GLMaterialTextureBase ../lib/gl-matrix ../lib/RenderSlot ../lib/RenderPass ../lib/ShaderVariations ../lib/ComponentUtils ../../support/aaBoundingRect ../lib/screenSizePerspectiveUtils".split(" "),function(P,ja,F,aa,f,p,z,ba,G,H,I,Q,L,ca,da,M){function N(f,b){void 0===b&&(b=R);if(f.textureIsSignedDistanceField){var a=
f.anchorPos;f=f.distanceFieldBoundingBox;var e=b;e[0]=a[0]*(f[2]-f[0])+f[0];e[1]=a[1]*(f[3]-f[1])+f[1]}else S.set(f.anchorPos,b);return b}var S=H.vec2d,u=H.vec3d,T=H.mat3d,A=H.mat4d,U={"bottom-left":[0,0],bottom:[.5,0],"bottom-right":[1,0],left:[0,.5],center:[.5,.5],right:[1,.5],"top-left":[0,1],top:[.5,1],"top-right":[1,1]},v=[{name:"position",count:3,type:5126,offset:0,stride:76,normalized:!1},{name:"normal",count:3,type:5126,offset:12,stride:76,normalized:!1},{name:"uv0",count:2,type:5126,offset:24,
stride:76,normalized:!1},{name:"color",count:4,type:5121,offset:32,stride:76,normalized:!1},{name:"size",count:2,type:5126,offset:36,stride:76,normalized:!1},{name:"auxpos1",count:4,type:5126,offset:44,stride:76,normalized:!1},{name:"auxpos2",count:4,type:5126,offset:60,stride:76,normalized:!1}],ea={texCoordScale:[1,1],occlusionTest:!0,binaryHighlightOcclusion:!0,drawInSecondSlot:!1,color:[1,1,1,1],outlineColor:[1,1,1,1],outlineSize:0,textureIsSignedDistanceField:!1,distanceFieldBoundingBox:null,
vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],screenOffset:[0,0],verticalOffset:null,screenSizePerspective:null,screenSizePerspectiveAlignment:null,anchorPos:U.center,shaderPolygonOffset:1E-5,polygonOffset:!1,textureId:null,centerOffsetUnits:"world",debugDrawBorder:!1};P=function(w){function b(a,e){e=w.call(this,
e)||this;return e._textureDirty=!1,e.params=f.copyParameters(a,ea),"string"==typeof e.params.anchorPos&&(e.params.anchorPos=U[e.params.anchorPos]),e}return F(b,w),b.prototype.dispose=function(){},b.prototype.getParameterValues=function(){var a=this.params;return{color:a.color,texCoordScale:a.texCoordScale,polygonOffset:a.polygonOffset,anchorPos:a.anchorPos,screenOffset:a.screenOffset,verticalOffset:a.verticalOffset,screenSizePerspective:a.screenSizePerspective,screenSizePerspectiveAlignment:a.screenSizePerspectiveAlignment,
shaderPolygonOffset:a.shaderPolygonOffset,textureIsSignedDistanceField:a.textureIsSignedDistanceField,outlineColor:a.outlineColor,outlineSize:a.outlineSize,distanceFieldBoundingBox:a.distanceFieldBoundingBox,vvSizeEnabled:a.vvSizeEnabled,vvSizeMinSize:a.vvSizeMinSize,vvSizeMaxSize:a.vvSizeMaxSize,vvSizeOffset:a.vvSizeOffset,vvSizeFactor:a.vvSizeFactor,vvColorEnabled:a.vvColorEnabled,vvColorValues:a.vvColorValues,vvColorColors:a.vvColorColors,textureId:a.textureId,occlusionTest:a.occlusionTest,binaryHighlightOcclusion:a.binaryHighlightOcclusion,
centerOffsetUnits:a.centerOffsetUnits,debugDrawBorder:a.debugDrawBorder,drawInSecondSlot:a.drawInSecondSlot}},b.prototype.setParameterValues=function(a){for(var e in a)"textureId"===e&&p.assert(!!this.params.textureId,"Can only change texture of material that already has a texture"),this.params[e]=a[e];this.notifyDirty("matChanged")},b.prototype.getParams=function(){return this.params},b.prototype.getOutputAmount=function(a){return 114*a},b.prototype.getInstanceBufferLayout=function(){},b.prototype.getVertexBufferLayout=
function(){return v},b.prototype.fillInterleaved=function(a,e,l,c,d,b){var t=4*b,q=a.indices[p.VertexAttrConstants.POSITION],x=a.vertexAttr[p.VertexAttrConstants.POSITION].data,n=b+z.findAttribute(v,p.VertexAttrConstants.POSITION).offset/4;for(c=0;c<q.length;++c){var g=3*q[c];f.fill(x,g,d,n,e,3);n+=19;f.fill(x,g,d,n,e,3);n+=19;f.fill(x,g,d,n,e,3);n+=19;f.fill(x,g,d,n,e,3);n+=19;f.fill(x,g,d,n,e,3);n+=19;f.fill(x,g,d,n,e,3);n+=19}e=a.indices[p.VertexAttrConstants.NORMAL];x=a.vertexAttr[p.VertexAttrConstants.NORMAL].data;
n=b+z.findAttribute(v,p.VertexAttrConstants.NORMAL).offset/4;for(c=0;c<e.length;++c)g=3*e[c],f.fill(x,g,d,n,l,3),n+=19,f.fill(x,g,d,n,l,3),n+=19,f.fill(x,g,d,n,l,3),n+=19,f.fill(x,g,d,n,l,3),n+=19,f.fill(x,g,d,n,l,3),n+=19,f.fill(x,g,d,n,l,3),n+=19;var k,m,h,r;c=a.vertexAttr[p.VertexAttrConstants.UV0].data;null==c||3>=c.length?(k=0,m=0,h=this.params.texCoordScale[0],r=this.params.texCoordScale[1]):(k=a.vertexAttr[p.VertexAttrConstants.UV0].data[0],m=a.vertexAttr[p.VertexAttrConstants.UV0].data[1],
h=a.vertexAttr[p.VertexAttrConstants.UV0].data[2],r=a.vertexAttr[p.VertexAttrConstants.UV0].data[3]);h=Math.min(1.99999,h+1);r=Math.min(1.99999,r+1);g=b+z.findAttribute(v,p.VertexAttrConstants.UV0).offset/4;for(c=0;c<q.length;++c)d[g]=k,d[g+1]=m,g+=19,d[g]=h,d[g+1]=m,g+=19,d[g]=h,d[g+1]=r,g+=19,d[g]=h,d[g+1]=r,g+=19,d[g]=k,d[g+1]=r,g+=19,d[g]=k,d[g+1]=m,g+=19;k=a.indices[p.VertexAttrConstants.COLOR];m=a.vertexAttr[p.VertexAttrConstants.COLOR].data;t+=z.findAttribute(v,p.VertexAttrConstants.COLOR).offset;
h=new Uint8Array(d.buffer);for(c=0;c<k.length;++c)g=4*k[c],f.fill(m,g,h,t,null,4),t+=76,f.fill(m,g,h,t,null,4),t+=76,f.fill(m,g,h,t,null,4),t+=76,f.fill(m,g,h,t,null,4),t+=76,f.fill(m,g,h,t,null,4),t+=76,f.fill(m,g,h,t,null,4),t+=76;g=a.indices[p.VertexAttrConstants.SIZE];t=a.vertexAttr[p.VertexAttrConstants.SIZE].data;k=b+z.findAttribute(v,p.VertexAttrConstants.SIZE).offset/4;for(c=0;c<g.length;++c)m=t[2*g[c]],h=t[2*g[c]+1],d[k]=m,d[k+1]=h,k+=19,d[k]=m,d[k+1]=h,k+=19,d[k]=m,d[k+1]=h,k+=19,d[k]=m,
d[k+1]=h,k+=19,d[k]=m,d[k+1]=h,k+=19,d[k]=m,d[k+1]=h,k+=19;if(null!=a.indices[p.VertexAttrConstants.AUXPOS1]&&null!=a.vertexAttr[p.VertexAttrConstants.AUXPOS1])for(t=a.indices[p.VertexAttrConstants.AUXPOS1],k=a.vertexAttr[p.VertexAttrConstants.AUXPOS1].data,m=b+z.findAttribute(v,"auxpos1").offset/4,c=0;c<t.length;++c)g=4*t[c],f.fill(k,g,d,m,null,4),m+=19,f.fill(k,g,d,m,null,4),m+=19,f.fill(k,g,d,m,null,4),m+=19,f.fill(k,g,d,m,null,4),m+=19,f.fill(k,g,d,m,null,4),m+=19,f.fill(k,g,d,m,null,4),m+=19;
if(null!=a.indices[p.VertexAttrConstants.AUXPOS2]&&null!=a.vertexAttr[p.VertexAttrConstants.AUXPOS2])for(t=a.indices[p.VertexAttrConstants.AUXPOS2],a=a.vertexAttr[p.VertexAttrConstants.AUXPOS2].data,b+=z.findAttribute(v,"auxpos2").offset/4,c=0;c<t.length;++c)g=4*t[c],f.fill(a,g,d,b,null,4),b+=19,f.fill(a,g,d,b,null,4),b+=19,f.fill(a,g,d,b,null,4),b+=19,f.fill(a,g,d,b,null,4),b+=19,f.fill(a,g,d,b,null,4),b+=19,f.fill(a,g,d,b,null,4),b+=19},b.prototype.intersect=function(a,e,b,c,d,f,t,q){if(c.isSelection&&
c.enableHUDSelection&&!ca.isAllHidden(e.componentVisibilities,a.data.componentOffsets)){var l=a.getData();a=this.params;d=e=1;if(A.toMat3(b,J),q){d=q(V);e=d[0];d=d[5];q=J;f=q[0];var n=q[1],g=q[2],k=q[3],m=q[4],h=q[5],r=q[6],w=q[7],v=q[8],C=1/Math.sqrt(f*f+n*n+g*g),D=1/Math.sqrt(k*k+m*m+h*h),z=1/Math.sqrt(r*r+w*w+v*v);q[0]=f*C;q[1]=n*C;q[2]=g*C;q[3]=k*D;q[4]=m*D;q[5]=h*D;q[6]=r*z;q[7]=w*z;q[8]=v*z}q=l.getVertexAttr()[p.VertexAttrConstants.POSITION];f=l.getVertexAttr()[p.VertexAttrConstants.SIZE];l=
l.getVertexAttr()[p.VertexAttrConstants.NORMAL];p.assert(3<=q.size);n=c.point;g=c.camera;k=N(a);for(m=0;m<q.data.length/q.size;m++)if(h=m*q.size,u.set3(q.data[h],q.data[h+1],q.data[h+2],B),A.multiplyVec3(b,B,B),h=m*f.size,y[0]=f.data[h]*e,y[1]=f.data[h+1]*d,A.multiplyVec3(g.viewMatrix,B),h=m*l.size,u.set3(l.data[h],l.data[h+1],l.data[h+2],W),this.applyVerticalOffsetTransformation(B,W,J,g,X),g.applyProjection(B,E),-1<E[0])h=Math.floor(E[0]),w=Math.floor(E[1]),M.applyPrecomputedScaleFactorVec2(y,X.factor,
y),h=h-K-(0<k[0]?y[0]*k[0]:0),r=h+y[0]+2*K,w=w-K-(0<k[1]?y[1]*k[1]:0),v=w+y[1]+2*K,a.textureIsSignedDistanceField&&(C=a.outlineSize/2,D=a.distanceFieldBoundingBox,h+=y[0]*D[0],w+=y[1]*D[1],r-=y[0]*(1-D[2]),v-=y[1]*(1-D[3]),h-=C,r+=C,w-=C,v+=C),n[0]>h&&n[0]<r&&n[1]>w&&n[1]<v&&(r=c.p0,w=c.p1,A.multiplyVec3(A.inverse(g.viewMatrix,fa),B,Y),E[0]=n[0],E[1]=n[1],g.unprojectPoint(E,B),h=u.negate(c.getDirection(),u.create()),r=u.dist(r,B)/u.dist(r,w),t(r,h,-1,1,!0,Y))}},b.prototype.normalAndViewAngle=function(a,
e,b,c){return void 0===c&&(c=O),T.multiplyVec3(e,a,c.normal),A.multiplyVec3(b.viewInverseTransposeMatrix,c.normal),c.cosAngle=u.dot(Z,ga),c},b.prototype.updateScaleInfo=function(a,e,b){e=this.params;e.screenSizePerspective?a.factor=M.precomputeScaleFactor(O.cosAngle,b,e.screenSizePerspective,a.factor):(a.factor.scale=1,a.factor.factor=0,a.factor.minPixelSize=0,a.factor.paddingPixels=0);e.screenSizePerspectiveAlignment?(a.scaleAlignment=M.precomputeScale(O.cosAngle,b,e.screenSizePerspectiveAlignment),
a.minPixelSizeAlignment=e.screenSizePerspectiveAlignment.parameters.minPixelSize):(a.scaleAlignment=a.factor.scale,a.minPixelSizeAlignment=a.factor.minPixelSize)},b.prototype.applyVerticalOffsetTransformation=function(a,e,b,c,d,r){var l=this.params;if(16===b.length&&(b=A.toMat3(b,J)),!l.verticalOffset||!l.verticalOffset.screenLength)return d&&(l.screenSizePerspective||l.screenSizePerspectiveAlignment)?(c=this.normalAndViewAngle(e,b,c),l=u.length(a),this.updateScaleInfo(d,c.cosAngle,l)):d&&(d.factor.scale=
1,d.scaleAlignment=1),r?u.set(a,r):a;e=this.normalAndViewAngle(e,b,c);b=u.length(a);c=f.verticalOffsetAtDistance(c,b,l.verticalOffset,e.cosAngle,l.screenSizePerspectiveAlignment||l.screenSizePerspective);return d&&this.updateScaleInfo(d,e.cosAngle,b),u.add(a,u.scale(e.normal,c),r)},b.prototype.getGLMaterials=function(){return{color:ha,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:ia}},b.prototype.getAllTextureIds=function(){return[this.params.textureId]},b.prototype.setTextureDirty=function(){this._textureDirty=
!0},b.prototype.calculateRelativeScreenBounds=function(a,e,b){void 0===b&&(b=da.create());var c=this.params,d=b;void 0===d&&(d=R);S.set(c.anchorPos,d);d[0]*=-a[0];d[1]*=-a[1];d[0]+=c.screenOffset[0]*e;d[1]+=c.screenOffset[1]*e;return b[2]=b[0]+a[0],b[3]=b[1]+a[1],b},b.prototype.calculateAnchorPosForRendering=function(a){return N(this.params,a)},b.loadShaders=function(a,b,l,c){a._parse(aa);var e=function(a){a.addDefine("OcclTest","OCCL_TEST");a.addDefine("SDF","SIGNED_DISTANCE_FIELD");a.addDefine("vvSize",
"VV_SIZE");a.addDefine("vvColor","VV_COLOR");a.addDefine("verticalOffset","VERTICAL_OFFSET");a.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");a.addDefine("centerOffsetUnitsScreen","CENTER_OFFSET_UNITS_SCREEN")},f=new L("hud",["vertexShaderHUD","fragmentShaderHUD"],null,l,b,a,c);e(f);f.addDefine("debugDrawBorder","DEBUG_DRAW_BORDER");l.addShaderVariations("hud-material-shader-variations",f);f=new L("hudHighlight",["vertexShaderHUD","fragmentShaderHUDHighlight"],null,l,b,a,c);e(f);f.addDefine("binaryHighlightOcclusion",
"BINARY_HIGHLIGHT_OCCLUSION");l.addShaderVariations("hud-material-highlight-shader-variations",f);a=new L("hudOcclusionTestPixel",["vertexShaderOcclusionTestPixel","fragmentShaderSimple"],null,l,b,a,c);a.addDefine("verticalOffset","VERTICAL_OFFSET");a.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");a.addDefine("centerOffsetUnitsScreen","CENTER_OFFSET_UNITS_SCREEN");l.addShaderVariations("hud-material-occlusion-test-pixel-shader-variations",a)},b.shouldRenderVisibilityDuringRenderPass=
function(a){return a===Q.MATERIAL||Q.MATERIAL_HIGHLIGHT},b}(ba.MaterialBase);G=function(p){function b(a,b,l){l=p.call(this,a,a.getParams(),b,l)||this;return l.programRep=b,l.params=f.copyParameters(a.getParams()),l.selectProgram(),l.selectSlot(),l}return F(b,p),b.prototype.selectSlot=function(){this.mainSlot=this.params.drawInSecondSlot?I.HUDMATERIAL2:I.HUDMATERIAL1},b.prototype.beginSlot=function(a){return a===this.mainSlot},b.prototype.getProgram=function(){return this.program},b.prototype.getAllPrograms=
function(){return[this.program]},b.prototype.updateParameters=function(){var a=this.material.getParams(),b=this.params;b.color=a.color;b.texCoordScale=a.texCoordScale;b.polygonOffset=a.polygonOffset;b.anchorPos=a.anchorPos;b.screenOffset=a.screenOffset;b.verticalOffset=a.verticalOffset;b.screenSizePerspective=a.screenSizePerspective;b.screenSizePerspectiveAlignment=a.screenSizePerspectiveAlignment;b.shaderPolygonOffset=a.shaderPolygonOffset;b.textureIsSignedDistanceField=a.textureIsSignedDistanceField;
b.outlineColor=a.outlineColor;b.outlineSize=a.outlineSize;b.vvSizeEnabled=a.vvSizeEnabled;b.vvSizeMinSize=a.vvSizeMinSize;b.vvSizeMaxSize=a.vvSizeMaxSize;b.vvSizeOffset=a.vvSizeOffset;b.vvSizeFactor=a.vvSizeFactor;b.vvColorEnabled=a.vvColorEnabled;b.vvColorValues=a.vvColorValues;b.vvColorColors=a.vvColorColors;this.updateTexture(a.textureId);this.selectProgram();this.selectSlot()},b.prototype.bindRender=function(a,b){var e=this.params,c=this.getProgram();this.bindTexture(a,c);c.setUniform1i("hudVisibilityTexture",
1);a.bindTexture(b.hudVisibilityTexture,1);a.setActiveTexture(0);c.setUniform4fv("overrideColor",e.color);c.setUniform1f("pixelRatio",b.pixelRatio);e.textureIsSignedDistanceField&&(c.setUniform4fv("outlineColor",e.outlineColor),c.setUniform1f("outlineSize",e.outlineSize));e.vvSizeEnabled&&(c.setUniform3fv("vvSizeMinSize",e.vvSizeMinSize),c.setUniform3fv("vvSizeMaxSize",e.vvSizeMaxSize),c.setUniform3fv("vvSizeOffset",e.vvSizeOffset),c.setUniform3fv("vvSizeFactor",e.vvSizeFactor));e.vvColorEnabled&&
(c.setUniform1fv("vvColorValues",e.vvColorValues),c.setUniform4fv("vvColorColors",e.vvColorColors));c.setUniform2fv("texScale",e.texCoordScale);c.setUniform2f("screenOffset",2*e.screenOffset[0],2*e.screenOffset[1]);c.setUniform2fv("anchorPos",N(e));e.polygonOffset&&(a.setPolygonOffsetFillEnabled(!0),a.setPolygonOffset(0,-4));a.setBlendingEnabled(!0);a.setBlendFunction(1,771)},b.prototype.bindProjection=function(a,b){this.material._textureDirty&&(this.renderTexture(a),this.material._textureDirty=!1);
var e=b.cameraAboveGround?1:-1,c=this.getProgram(),d=this.params;a.bindProgram(c);c.setUniform1f("cameraGroundRelative",e);c.setUniform1f("polygonOffset",d.shaderPolygonOffset);c.setUniform4fv("viewport",b.viewport);f.bindVerticalOffset(d.verticalOffset,b,c);c.setUniformMatrix4fv("viewNormal",b.viewInvTransp);d.screenSizePerspective&&(f.bindScreenSizePerspective(d.screenSizePerspective,c,"screenSizePerspective"),f.bindScreenSizePerspective(d.screenSizePerspectiveAlignment||d.screenSizePerspective,
c,"screenSizePerspectiveAlignment"))},b.prototype.releaseRender=function(a){a.setPolygonOffsetFillEnabled(!1);a.setBlendFunction(770,771);a.setBlendingEnabled(!1)},b.prototype.bindView=function(a,b){a=b.origin;var e=this.getProgram();f.bindView(a,b.view,e);f.bindCamPos(a,b.viewInvTransp,e)},b.prototype.bindInstance=function(a,b){a=this.getProgram();a.setUniformMatrix4fv("model",b.transformation);a.setUniformMatrix4fv("modelNormal",b.transformationNormal)},b.prototype.getDrawMode=function(a){return a.gl.TRIANGLES},
b}(G.GLMaterialTextureBase);var ha=function(f){function b(a,b,l){a=f.call(this,a,b,l)||this;return a.isOcclusionSlot=!1,a}return F(b,f),b.prototype.selectProgram=function(){var a=this.params;this.programOcclusionTestPixel=this.programRep.getShaderVariationsProgram("hud-material-occlusion-test-pixel-shader-variations",[!!a.verticalOffset,!!a.screenSizePerspective,"screen"===a.centerOffsetUnits]);this.program=this.programRep.getShaderVariationsProgram("hud-material-shader-variations",[a.occlusionTest,
a.textureIsSignedDistanceField,!!a.vvSizeEnabled,!!a.vvColorEnabled,!!a.verticalOffset,!!a.screenSizePerspective,"screen"===a.centerOffsetUnits,!!a.debugDrawBorder])},b.prototype.getDrawMode=function(a){a=a.gl;return this.isOcclusionSlot?a.POINTS:a.TRIANGLES},b.prototype.release=function(a){a.setDepthFunction(a.gl.LESS);this.isOcclusionSlot||this.releaseRender(a)},b.prototype.bind=function(a,b){var e=a.gl;this.bindProjection(a,b);var c=this.getProgram();a.setDepthFunction(e.LEQUAL);this.isOcclusionSlot?
c.setUniform4f("color",1,1,1,1):(this.bindRender(a,b),this.bindTexture(a,c))},b.prototype.getProgram=function(){return this.isOcclusionSlot?this.programOcclusionTestPixel:this.program},b.prototype.getAllPrograms=function(){return[this.programOcclusionTestPixel,this.program]},b.prototype.beginSlot=function(a){return this.params.occlusionTest?(this.isOcclusionSlot=a===I.OCCLUSION_PIXELS,a===I.OCCLUSION_PIXELS||a===this.mainSlot):(this.isOcclusionSlot=!1,a===this.mainSlot)},b}(G),ia=function(f){function b(){return null!==
f&&f.apply(this,arguments)||this}return F(b,f),b.prototype.selectProgram=function(){var a=this.params;this.program=this.programRep.getShaderVariationsProgram("hud-material-highlight-shader-variations",[a.occlusionTest,a.textureIsSignedDistanceField,!!a.vvSizeEnabled,!!a.vvColorEnabled,!!a.verticalOffset,!!a.screenSizePerspective,"screen"===a.centerOffsetUnits,a.binaryHighlightOcclusion])},b.prototype.bind=function(a,b){this.bindProjection(a,b);this.bindRender(a,b)},b.prototype.release=function(a){this.releaseRender(a)},
b}(G),X={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},scaleAlignment:0,minPixelSizeAlignment:0},R=[0,0],B=u.create(),W=u.create(),E=u.create(),Z=u.create(),Y=u.create(),J=T.create(),fa=A.create(),O={normal:Z,cosAngle:0},V=A.create();A.identity(V);var K=1,y=[0,0],ga=[0,0,1];return P});