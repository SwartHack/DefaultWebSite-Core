//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/Material.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\n\n\x3csnippets\x3e\n\n\x3csnippet name\x3d"calculateVerticalOffset"\x3e\x3c![CDATA[\n  $viewingMode\n\n#ifdef VERTICAL_OFFSET\n  // [ verticalOffsetPerDistance, minWorldLength, maxWorldLength ]\n  uniform vec4 verticalOffset;\n\n#ifdef SCREEN_SIZE_PERSPECTIVE\n\n  uniform vec4 screenSizePerspectiveAlignment;\n\n  $screenSizePerspective\n\n#endif\n\n  vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n    float viewDistance \x3d length((view * vec4(worldPos, 1)).xyz);\n    float verticalOffsetOffsetDistance \x3d verticalOffset.x * viewDistance;\n\n#ifdef VIEWING_MODE_GLOBAL\n    vec3 worldNormal \x3d normalize(worldPos + localOrigin);\n#else\n    vec3 worldNormal \x3d vec3(0, 0, 1);\n#endif\n\n#ifdef SCREEN_SIZE_PERSPECTIVE\n    float cosAngle \x3d dot(worldNormal, normalize(worldPos - camPos));\n\n    float verticalOffsetScreenHeight \x3d screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);\n#else\n    float verticalOffsetScreenHeight \x3d verticalOffset.x;\n#endif\n\n    // Screen sized offset in world space, used for example for line callouts\n    float worldOffset \x3d clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n\n    return worldNormal * worldOffset;\n  }\n#endif\n]]\x3e\n\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsPhongSrc"\x3e\x3c![CDATA[\n\tuniform mat4 proj;\n\tuniform mat4 view;\n  uniform vec3 camPos;\n\n\tuniform vec3 localOrigin;\n\n#ifdef INSTANCED\n    attribute mat4 model;\n    attribute mat4 modelNormal;\n#else\n\tuniform mat4 model;\n\tuniform mat4 modelNormal;\n#endif\n#ifdef INSTANCEDCOLOR\n\tattribute vec4 instanceColor;\n#endif\n\tattribute vec3 $position;\n\tattribute vec3 $normal;\n\tvarying vec3 vpos;\n\tvarying vec3 vnormal;\n\n#ifdef RECEIVE_SHADOWS\n\tvarying float linearDepth;\n#endif\n\n#ifdef VERTEXCOLORS\n\tattribute vec4 $color;\n#endif\n\n#ifdef SYMBOLVERTEXCOLORS\n  attribute vec4 $symbolColor;\n#endif\n\n#if defined(VV_SIZE) || defined(VV_COLOR)\n\tattribute vec4 instanceFeatureAttribute;\n#endif\n\n$vvUniforms\n\n#if defined(VERTEXCOLORS)\n\tvarying vec4 vcolor;\n#endif\n\n#if defined(INSTANCEDCOLOR) || defined(VV_COLOR) || defined(SYMBOLVERTEXCOLORS)\n\tuniform vec4 externalColor;\n\tvarying vec4 vcolorExt;\n#endif\n\n#if defined(SYMBOLVERTEXCOLORS)\n\tvarying mediump float colorMixMode; // varying int is not supported in WebGL\n#endif\n\n\t$vvFunctions\n\n\t$colorMixMode\n\n  $calculateVerticalOffset\n\n\tvoid main(void) {\n\n#ifdef VV_CUSTOM_MODEL_MATRIX\n\n\t\tvpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\n\t\tvnormal \x3d normalize((modelNormal * vvTransformNormal($normal, instanceFeatureAttribute)).xyz);\n\n#ifdef VERTICAL_OFFSET\n\t\tvec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\n#endif\n\n#else /* VV_CUSTOM_MODEL_MATRIX */\n\n\t\tvpos \x3d (model * vec4($position, 1.0)).xyz;\n\t\tvnormal \x3d normalize((modelNormal * vec4($normal, 1.0)).xyz);\n\n#ifdef VERTICAL_OFFSET\n\t\tvec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\n#endif\n\n#endif /* VV_CUSTOM_MODEL_MATRIX */\n\n#ifdef VERTICAL_OFFSET\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\n#endif\n\n\t\tgl_Position \x3d proj * view * vec4(vpos, 1.0);\n\n#ifdef RECEIVE_SHADOWS\n\t\t// Shadowmap\'s cascading index used to be based on \'1.0 / gl_FragCoord.w\'\n\t\t// (i.e. the perspective interpolation of \'gl_Position.w\'). Precision\n\t\t// issues on iPad/iPhone with the \'w\' component require the depth to be\n\t\t// passed as varying to properly drive the cascading shadow map index.\n\t\tlinearDepth \x3d gl_Position.w;\n#endif\n\n#ifdef VERTEXCOLORS\n\t\tvcolor \x3d $color * 0.003921568627451; // \x3d 1/255\n#endif\n\n#if defined(INSTANCEDCOLOR) || defined(VV_COLOR) || defined(SYMBOLVERTEXCOLORS)\n\t\tvcolorExt \x3d externalColor;\n#endif\n#ifdef INSTANCEDCOLOR\n\t\tvcolorExt *\x3d instanceColor;\n#endif\n#ifdef VV_COLOR\n\t\tvcolorExt *\x3d vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);\n#endif\n#ifdef SYMBOLVERTEXCOLORS\n    int symbolColorMixMode;\n    vcolorExt *\x3d decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\n    colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\n#endif\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsPhongSrc"\x3e\x3c![CDATA[\n  $fsprecisionf\n\n\tuniform vec3 camPos;\n\tuniform vec3 localOrigin;\n\n\t$sceneLightingDefinitions\n\n\t// material parameters\n\t//////////////////////////////////////////\n\tuniform vec3 ambient;\n\tuniform vec3 diffuse;\n\tuniform vec3 specular;\n\tuniform float shininess;\n\tuniform float opacity;\n\tuniform float layerOpacity;\n\n#ifdef SYMBOLVERTEXCOLORS\n\tvarying mediump float colorMixMode; // varying int is not supported in WebGL\n#else\n  uniform int colorMixMode;\n#endif\n\n#ifdef RECEIVE_SHADOWS\n\tuniform sampler2D depthTex;\n\tuniform int shadowMapNum;\n\tuniform vec4 shadowMapDistance;\n\tuniform mat4 shadowMapMatrix[4];\n\tuniform float depthHalfPixelSz;\n#endif\n\n#ifdef RECEIVE_SSAO\n\tuniform sampler2D ssaoTex;\n\tuniform vec4 viewportPixelSz;\n#endif\n\n\n\tvarying vec3 vpos;\n\tvarying vec3 vnormal;\n#if defined(VERTEXCOLORS)\n\tvarying vec4 vcolor;\n#endif\n#if defined(INSTANCEDCOLOR) || defined(VV_COLOR) || defined(SYMBOLVERTEXCOLORS)\n\tvarying vec4 vcolorExt;\n#else\n\tuniform vec4 externalColor;\n#endif\n\n#ifdef RECEIVE_SHADOWS\n\tvarying float linearDepth;\n\t$evalShadow\n#endif\n\n\t$colorMixMode\n\n\tvoid main() {\n\t\tvec3 viewDir \x3d normalize(vpos - camPos);\n\n\t\t$computeNormal\n\n\t\tvec3 reflDir \x3d normalize(reflect(viewDir, normal));\n\n\t\t// compute ssao\n\t\t#ifdef RECEIVE_SSAO\n\t\t\t\tfloat ssao \x3d texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n\t\t\t\tssao \x3d viewportPixelSz.z \x3c 0.0 ? 1.0 : ssao;\n\t\t#else\n\t\t\t\tfloat ssao \x3d 1.0;\n\t\t#endif\n\n\t\t// At global scale we create some additional ambient light based on the main light to simulate global illumination\n\t\t// This also defines "additionalAmbientScale" which might be used as a shadow fallback further down\n\t\t$sceneLightingAdditionalLightGlobal\n\n\t\t// compute shadowing\n\t\tfloat shadow \x3d 0.0;\n\t\t#ifdef RECEIVE_SHADOWS\n\t\t\tshadow \x3d evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\n\t\t#elif defined(VIEWING_MODE_GLOBAL)\n\t\t\t// at global scale (and in global scenes) we fall back to this approximation\n\t\t\t// to shadow objects on the dark side of the earth\n\t\t\tshadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\n\t\t#endif\n\n\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"externalColorMix"\x3e\x3c![CDATA[\n\tvec3 matColor \x3d max(ambient, diffuse); // combine the old material parameters into a single one\n\t#if defined(VERTEXCOLORS) \x26\x26 (defined(INSTANCEDCOLOR) || defined(VV_COLOR) || defined(SYMBOLVERTEXCOLORS))\n\t\t\t// Internal colors: varying vcolor + uniform ambient/diffuse, external colors: varying vcolorExt\n\t\t\tvec3 albedo_ \x3d mixExternalColor(vcolor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n\t\t\tfloat opacity_ \x3d layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n\t#elif defined(VERTEXCOLORS)\n\t\t\t// Internal colors: varying vcolor + uniform ambient/diffuse, external colors: uniform externalColor\n\t\t\tvec3 albedo_ \x3d mixExternalColor(vcolor.rgb * matColor, texColor.rgb, externalColor.rgb, int(colorMixMode));\n\t\t\tfloat opacity_ \x3d layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, externalColor.a, int(colorMixMode));\n\t#elif defined(INSTANCEDCOLOR) || defined(VV_COLOR) || defined(SYMBOLVERTEXCOLORS)\n\t\t\t// Internal colors: uniform ambient/diffuse, external colors: varying vcolorExt\n\t\t\tvec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n\t\t\tfloat opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n\t#else\n\t\t\t// Internal colors: uniform ambient/diffuse, external colors: uniform externalColor\n\t\t\tvec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, externalColor.rgb, int(colorMixMode));\n\t\t\tfloat opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, externalColor.a, int(colorMixMode));\n\t#endif\n\talbedo_+\x3d 0.25 * specular; // don\'t completely ignore specular for now\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsPhong"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n\t$vsPhongSrc\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsPhong"\x3e\x3c![CDATA[\n\t\t$fsprecisionf\n\n\t\t$fsPhongSrc\n\n\t\tvec4 texColor \x3d vec4(1,1,1,1);\n\t\t$externalColorMix\n\n\t\tvec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\n\t\tgl_FragColor \x3d vec4(shadedColor, opacity_);\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsPhongTextured"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n\tattribute vec2 $uv0;\n\tvarying vec2 vtc;\n\t$vsPhongSrc\n#ifndef FLIPV\n\t\tvtc \x3d $uv0;\n#else\n\t\tvtc \x3d vec2($uv0.x, 1.0-$uv0.y);\n#endif\n\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsPhongTextured"\x3e\x3c![CDATA[\n\t$fsprecisionf\n\n\tuniform sampler2D tex;\n\tvarying vec2 vtc;\n\n\t$fsPhongSrc\n\n\t\t// read texture color\n\t\tvec4 texColor \x3d texture2D(tex, vtc);\n\t\tif (texColor.a \x3c .33) discard;\n\n\t\t$externalColorMix\n\n\t\tvec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\n\n\t\tgl_FragColor \x3d vec4(shadedColor, opacity_);\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsPhongAtlasTextured"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n\tattribute vec4 $uv0;\n\tattribute vec4 $region;\n\tvarying vec2 vtc;\n\tvarying vec4 regionV;\n\t$vsPhongSrc\n#ifndef FLIPV\n\t\tvtc \x3d $uv0.xy;\n#else\n\t\tvtc \x3d vec2($uv0.x, 1.0-$uv0.y);\n#endif\n\t\tregionV \x3d $region/65535.0;\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsPhongAtlasTextured"\x3e\x3c![CDATA[\n\t$fsprecisionf\n\n\tuniform sampler2D tex;\n\tuniform vec2 texSize;\n\tvarying vec2 vtc;\n\tvarying vec4 regionV;\n\n\tfloat calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n\t\t// from:\n\t\t//   - OpenGLES Common Profile Specification Version 2.0.25, Section 3.7.7 - Texture Minification\n\t\t//   - https://www.opengl.org/discussion_boards/showthread.php/171485-Texture-LOD-calculation-(useful-for-atlasing)\n\t\t//   - http://www.linedef.com/virtual-texture-demo.html\n\t\tfloat deltaMaxSqr \x3d max(dot(ddx, ddx), dot(ddy, ddy));\n\t\treturn max(0.5 * log2(deltaMaxSqr), 0.0);\n\t}\n\n\t$fsPhongSrc\n\n\t\tvec2 uv \x3d vtc;\n\t\tuv \x3d fract(uv);\n\t\t//[umin, vmin, umax, vmax]\n\n\t\tvec2 atlasScale \x3d regionV.zw - regionV.xy;\n\t\tuv \x3d uv.xy * atlasScale + regionV.xy;\n\n\t\tvec4 texColor;\n\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t#extension GL_OES_standard_derivatives : enable\n\n\t\t\t// calculate derivative of continuous texture coordinate\n\t\t\t// to avoid mipmapping artifacts caused by manual wrapping in shader\n\t\t\tvec2 dUVdx \x3d dFdx(vtc) * atlasScale;\n\t\t\tvec2 dUVdy \x3d dFdy(vtc) * atlasScale;\n\n\t\t\t#ifdef GL_EXT_shader_texture_lod\n\t\t\t\t#extension GL_EXT_shader_texture_lod : enable\n\n\t\t\t\t// workaround for artifacts in Windows 10 using Intel HD Graphics 4000 series\n\t\t\t\t// see: https://devtopia.esri.com/Zurich-R-D-Center/arcgis-js-api-canvas3d-issues/issues/768\n\t\t\t\tconst float epsilon \x3d 1.0E-32;\n\t\t\t\tfloat zeroUVShift \x3d uv.x \x3d\x3d 0.0 \x26\x26 uv.y \x3d\x3d 0.0 ? epsilon : 0.0;\n\n\t\t\t\ttexColor \x3d texture2DGradEXT(tex, uv + zeroUVShift, dUVdx, dUVdy);\n\t\t\t#else\n\t\t\t\t// use bias to compensate for difference in automatic vs desired mipmap level\n\t\t\t\tvec2 dUVdxAuto \x3d dFdx(uv);\n\t\t\t\tvec2 dUVdyAuto \x3d dFdy(uv);\n\t\t\t\tfloat mipMapLevel \x3d calcMipMapLevel(dUVdx * texSize, dUVdy * texSize);\n\t\t\t\tfloat autoMipMapLevel \x3d calcMipMapLevel(dUVdxAuto * texSize, dUVdyAuto * texSize);\n\t\t\t\ttexColor \x3d texture2D(tex, uv, mipMapLevel - autoMipMapLevel);\n\t\t\t#endif\n\t\t#else\n\t\t\ttexColor \x3d texture2D(tex, uv);\n\t\t#endif\n\n\t\tif (texColor.a \x3c .33) discard;\n\n\t\t$externalColorMix\n\n\t\tvec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\n\t\tgl_FragColor \x3d vec4(shadedColor, opacity_);\n\t}\n\t]]\x3e\x3c/snippet\x3e\n\n\t\x3csnippet name\x3d"fsPhongTexturedRefl"\x3e\x3c![CDATA[\n\t\t$fsprecisionf\n\n\t\tuniform sampler2D tex;\n\t\tuniform sampler2D reflTex;\n\t\tuniform float reflectivity;\n\t\tvarying vec2 vtc;\n\n\t\t$normal2envTC\n\n\t\t$fsPhongSrc\n\t\tvec4 texColor \x3d texture2D(tex, vtc);\n\t\tif (texColor.a \x3c .33) discard;\n\t\tvec4 reflColor \x3d texture2D(reflTex, normal2envTC(reflDir));\n\n\t\t$externalColorMix\n\n\t\tvec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\n\t\tshadedColor.rgb \x3d mix(shadedColor.rgb, reflColor.rgb, reflectivity);\n\n\t\tgl_FragColor \x3d vec4(shadedColor, opacity_);\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsDepthSrc"\x3e\x3c![CDATA[\n\tuniform mat4 proj;\n\tuniform mat4 view;\n  uniform vec3 camPos;\n  uniform vec3 localOrigin;\n\n#ifdef INSTANCED\n\tattribute mat4 model;\n  attribute mat4 modelNormal;\n#else\n\tuniform mat4 model;\n  uniform mat4 modelNormal;\n#endif\n\tuniform vec2 nearFar;\n\tattribute vec3 $position;\n\tvarying float depth;\n\n\t$vvUniforms\n#if defined(VV_CUSTOM_MODEL_MATRIX)\n\tattribute vec4 instanceFeatureAttribute;\n#endif\n\t$vvFunctions\n\n  $calculateVerticalOffset\n\n\tvoid main(void) {\n\n#ifdef VV_CUSTOM_MODEL_MATRIX\n\n    vec3 vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\n#endif\n\n#else /* VV_CUSTOM_MODEL_MATRIX */\n\n\t\tvec3 vpos \x3d (model * vec4($position, 1.0)).xyz;\n\n#ifdef VERTICAL_OFFSET\n\t\tvec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\n#endif\n\n#endif /* VV_CUSTOM_MODEL_MATRIX */\n\n#ifdef VERTICAL_OFFSET\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\n#endif\n\n    vec4 eye \x3d view * vec4(vpos, 1);\n\n\t\tgl_Position \x3d proj * eye;\n\t\tdepth \x3d (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsDepth"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n\t$vsDepthSrc\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsDepthTextured"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n\tattribute vec2 $uv0;\n\tvarying vec2 vtc;\n\t$vsDepthSrc\n#ifndef FLIPV\n        vtc \x3d $uv0;\n#else\n        vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\n#endif\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsNormalSrc"\x3e\x3c![CDATA[\n\tuniform mat4 proj;\n\tuniform mat4 view;\n  uniform vec3 camPos;\n  uniform vec3 localOrigin;\n\n#ifdef INSTANCED\n\tattribute mat4 model;\n\tattribute mat4 modelNormal;\n#else\n\tuniform mat4 model;\n\tuniform mat4 modelNormal;\n#endif\n\tuniform mat4 viewNormal;\n\tattribute vec3 $position;\n\tattribute vec3 $normal;\n\tvarying vec3 vnormal;\n\n\t$vvUniforms\n#if defined(VV_CUSTOM_MODEL_MATRIX)\n\tattribute vec4 instanceFeatureAttribute;\n#endif\n\t$vvFunctions\n\n  $calculateVerticalOffset\n\n\tvoid main(void) {\n\n#ifdef VV_CUSTOM_MODEL_MATRIX\n\n    vec3 vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\n\t\tvnormal \x3d normalize((viewNormal * modelNormal * vvTransformNormal($normal, instanceFeatureAttribute)).xyz);\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\n#endif\n\n#else /* VV_CUSTOM_MODEL_MATRIX */\n\t\tvec3 vpos \x3d (model * vec4($position, 1.0)).xyz;\n\t\tvnormal \x3d normalize((viewNormal * modelNormal * vec4($normal, 1.0)).xyz);\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\n#endif\n\n#endif /* VV_CUSTOM_MODEL_MATRIX */\n\n#ifdef VERTICAL_OFFSET\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\n#endif\n\n    gl_Position \x3d proj * view * vec4(vpos, 1);\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsNormal"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n\t$vsNormalSrc\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsNormalTextured"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n\tattribute vec2 $uv0;\n\tvarying vec2 vtc;\n\t$vsNormalSrc\n#ifndef FLIPV\n\t\tvtc \x3d $uv0;\n#else\n\t\tvtc \x3d vec2($uv0.x, 1.0-$uv0.y);\n#endif\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsHighlightSrc"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n\tuniform mat4 proj;\n\tuniform mat4 view;\n  uniform vec3 camPos;\n  uniform vec3 localOrigin;\n\n#ifdef INSTANCED\n\tattribute mat4 model;\n  attribute mat4 modelNormal;\n#else\n\tuniform mat4 model;\n  uniform mat4 modelNormal;\n#endif\n\tattribute vec3 $position;\n\n\t$vvUniforms\n#if defined(VV_CUSTOM_MODEL_MATRIX)\n\tattribute vec4 instanceFeatureAttribute;\n#endif\n\t$vvFunctions\n\n  $calculateVerticalOffset\n\n\tvoid main(void) {\n\n#ifdef VV_CUSTOM_MODEL_MATRIX\n\n    vec3 vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\n#endif\n\n#else /* VV_CUSTOM_MODEL_MATRIX */\n\n    vec3 vpos \x3d (model * vec4($position, 1.0)).xyz;\n\n#ifdef VERTICAL_OFFSET\n    vec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\n#endif\n\n#endif /* VV_CUSTOM_MODEL_MATRIX */\n\n#ifdef VERTICAL_OFFSET\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\n#endif\n\n\t\tgl_Position \x3d proj * view * vec4(vpos, 1);\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsHighlight"\x3e\x3c![CDATA[\n\t$vsHighlightSrc\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"vsHighlightTextured"\x3e\x3c![CDATA[\n  $vsprecisionf\n\n\tattribute vec2 $uv0;\n\tvarying vec2 vtc;\n\t$vsHighlightSrc\n#ifndef FLIPV\n\t\tvtc \x3d $uv0;\n#else\n\t\tvtc \x3d vec2($uv0.x, 1.0-$uv0.y);\n#endif\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsDepthSrc"\x3e\x3c![CDATA[\n  $fsprecisionf\n\tvarying float depth;\n\n\tvoid main() {\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsDepth"\x3e\x3c![CDATA[\n\t$fsprecisionf\n\n\t$calcFragDepth\n\t$float2rgba\n\t$fsDepthSrc\n#ifndef BIAS_SHADOWMAP\n\t\tgl_FragColor \x3d float2rgba(depth);\n#else\n\t\tgl_FragColor \x3d float2rgba(calcFragDepth(depth));\n#endif\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsDepthTextured"\x3e\x3c![CDATA[\n\t$fsprecisionf\n\n\tuniform sampler2D tex;\n\tvarying vec2 vtc;\n\t$calcFragDepth\n\t$float2rgba\n\n\t$fsDepthSrc\n\t\tif (texture2D(tex, vtc).a \x3c .33) discard;\n#ifndef BIAS_SHADOWMAP\n\t\tgl_FragColor \x3d float2rgba(depth);\n#else\n\t\tgl_FragColor \x3d float2rgba(calcFragDepth(depth));\n#endif\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsNormal"\x3e\x3c![CDATA[\n\t$fsprecisionf\n\n\tvarying vec3 vnormal;\n\tvoid main() {\n\t\tvec3 normal \x3d normalize(vnormal);\n\t\tif (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\n\n#ifndef ALPHA_ZERO\n\t\tgl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\n#else\n\t\tgl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\n#endif\n\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsNormalTextured"\x3e\x3c![CDATA[\n\t$fsprecisionf\n\n\tvarying vec3 vnormal;\n\tvarying vec2 vtc;\n\tuniform sampler2D tex;\n\tvoid main() {\n\t\tif (texture2D(tex, vtc).a \x3c .33) discard;\n\t\tvec3 normal \x3d normalize(vnormal);\n\t\tif (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\n#ifndef ALPHA_ZERO\n\t\tgl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\n#else\n\t\tgl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\n#endif\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsHighlight"\x3e\x3c![CDATA[\n\t$fsprecisionf\n  uniform sampler2D depthTex;\n  uniform vec4 highlightViewportPixelSz;\n\n\tvoid main() {\n\t\t$highlightWrite\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3csnippet name\x3d"fsHighlightTextured"\x3e\x3c![CDATA[\n\t$fsprecisionf\n\n\tvarying vec2 vtc;\n\tuniform sampler2D tex;\n  uniform sampler2D depthTex;\n  uniform vec4 highlightViewportPixelSz;\n\n\tvoid main() {\n\t\tif (texture2D(tex, vtc).a \x3c .33) discard;\n\n\t\t$highlightWrite\n\t}\n]]\x3e\x3c/snippet\x3e\n\n\x3c/snippets\x3e\n'}});
define("dojo/text!./Material.xml ./internal/MaterialUtil ../../../webgl/Program ../lib/ShaderVariations ../lib/Util ../lib/gl-matrix ../lib/RenderSlot ../lib/DefaultVertexAttributeLocations ../lib/DefaultVertexBufferLayouts ../../../webgl/Util ../../layers/graphics/graphicUtils".split(" "),function(Q,f,n,y,R,z,E,p,S,t,T){function A(a,c){var e=c.vvSizeEnabled;c.vvSizeEnabled?(a.setUniform3fv("vvSizeMinSize",c.vvSizeMinSize),a.setUniform3fv("vvSizeMaxSize",c.vvSizeMaxSize),a.setUniform3fv("vvSizeOffset",
c.vvSizeOffset),a.setUniform3fv("vvSizeFactor",c.vvSizeFactor)):e&&a.setUniform3fv("vvSizeValue",c.vvSizeValue);e&&(a.setUniform3fv("vvSymbolAnchor",c.vvSymbolAnchor),T.computeObjectRotation(c.vvSymbolRotation[2],c.vvSymbolRotation[0],c.vvSymbolRotation[1],F.identity(K)),a.setUniformMatrix3fv("vvSymbolRotation",F.toMat3(K,U)));c.vvColorEnabled&&(a.setUniform1fv("vvColorValues",c.vvColorValues),a.setUniform4fv("vvColorColors",c.vvColorColors))}function B(a,c){a.vvSizeEnabled=c.vvSizeEnabled;a.vvSizeMinSize=
c.vvSizeMinSize;a.vvSizeMaxSize=c.vvSizeMaxSize;a.vvSizeOffset=c.vvSizeOffset;a.vvSizeFactor=c.vvSizeFactor;a.vvSizeValue=c.vvSizeValue;a.vvSymbolAnchor=c.vvSymbolAnchor;a.vvSymbolRotation=c.vvSymbolRotation}function V(a,c){return G.set(a,L),G.multiply(c,L)}var u,H=R.assert,g=z.vec3,G=z.vec4,M=z.mat3,F=z.mat4,L=G.create(),U=M.create(),K=F.create(),W=g.create(),X=g.create(),Y=g.createFrom(0,0,1),N=g.create(),I=g.create(),J=g.create(),Z=g.create(),v=function(a,c){f.basicMaterialConstructor(this,c);
a=a||{};a.ambient=a.ambient||[.2,.2,.2];a.diffuse=a.diffuse||[.8,.8,.8];a.specular=a.specular||[0,0,0];a.externalColor=a.externalColor||[1,1,1,1];a.colorMixMode=a.colorMixMode||"multiply";a.shininess=a.shininess||10;a.opacity=void 0!==a.opacity?a.opacity:1;a.layerOpacity=void 0!==a.layerOpacity?a.layerOpacity:1;a.blendModeOneOne=a.blendModeOneOne||!1;a.inverseWindingOrder=a.inverseWindingOrder||!1;a.vertexColors=a.vertexColors||!1;a.symbolColors=a.symbolColors||!1;a.flipV=a.flipV||!1;a.doubleSided=
a.doubleSided||!1;a.cullFace=a.cullFace||void 0;a.instanced=a.instanced||!1;this.instanced=!!a.instanced;a.groundNormalShading=a.groundNormalShading||!1;a.writeStencil=a.writeStencil||!1;a.textureId||(a.reflTextureId=void 0);a.receiveSSAO=void 0!==a.receiveSSAO?a.receiveSSAO:!0;a.castShadows=void 0!==a.castShadows?a.castShadows:!0;a.verticalOffset=a.verticalOffset||null;a.screenSizePerspective=a.screenSizePerspective||null;a.vvSizeEnabled=a.vvSizeEnabled||!1;a.vvSizeMinSize=a.vvSizeMinSize||[1,1,
1];a.vvSizeMaxSize=a.vvSizeMaxSize||[100,100,100];a.vvSizeOffset=a.vvSizeOffset||[0,0,0];a.vvSizeFactor=a.vvSizeFactor||[1,1,1];a.vvSizeValue=a.vvSizeValue||[1,1,1];a.vvColorEnabled=a.vvColorEnabled||!1;a.vvColorValues=a.vvColorValues||[0,0,0,0,0,0,0,0];a.vvColorColors=a.vvColorColors||[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0];a.vvSymbolAnchor=a.vvSymbolAnchor||[0,0,0];a.vvSymbolRotation=a.vvSymbolRotation||[0,0,0];var e=v.getVertexBufferLayout(a),b=null;a.instanced&&(b=[],
t.addDescriptor(b,"model",16,5126,!1,1),t.addDescriptor(b,"modelNormal",16,5126,!1,1),-1<a.instanced.indexOf("color")&&t.addDescriptor(b,"instanceColor",4,5126,!1,1),-1<a.instanced.indexOf("featureAttribute")&&t.addDescriptor(b,"instanceFeatureAttribute",4,5126,!1,1));var d=this.isVisible.bind(this);this.isVisible=function(){return d()&&0<a.opacity&&0<a.layerOpacity};this.dispose=function(){};this.getParams=function(){return a};this.getParameterValues=function(){var b={ambient:a.ambient,diffuse:a.diffuse,
specular:a.specular,externalColor:a.externalColor,colorMixMode:a.colorMixMode,shininess:a.shininess,opacity:a.opacity,layerOpacity:a.layerOpacity,transparent:a.transparent,polygonOffset:a.polygonOffset,reflectivity:a.reflectivity,atlasRegions:a.atlasRegions,flipV:a.flipV,doubleSided:a.doubleSided,cullFace:a.cullFace,writeStencil:a.writeStencil,receiveSSAO:a.receiveSSAO,castShadows:a.castShadows,verticalOffset:a.verticalOffset,screenSizePerspective:a.screenSizePerspective,vvSizeEnabled:a.vvSizeEnabled,
vvSizeMinSize:a.vvSizeMinSize,vvSizeMaxSize:a.vvSizeMaxSize,vvSizeOffset:a.vvSizeOffset,vvSizeFactor:a.vvSizeFactor,vvSizeValue:a.vvSizeValue,vvColorEnabled:a.vvColorEnabled,vvColorValues:a.vvColorValues,vvColorColors:a.vvColorColors,groundNormalShading:a.groundNormalShading,vvSymbolAnchor:a.vvSymbolAnchor,vvSymbolRotation:a.vvSymbolRotation};return a.textureId&&(b.textureId=a.textureId,b.initTexture=a.initTexture),b};this.setParameterValues=function(b){for(var d in b)"textureId"===d&&H(a.textureId,
"Can only change texture of material that already has a texture"),"castShadows"===d&&H(b.castShadows===a.castShadows,"Can not change shadow casting behavior."),a[d]=b[d];this.notifyDirty("matChanged")};this.getOutputAmount=function(a){var b=t.getStride(e)/4;return a*b};this.getVertexBufferLayout=function(){return e};this.getInstanceBufferLayout=function(){return b};this.fillInterleaved=function(a,b,d,c,r,l,k){f.fillInterleaved(a,b,d,c,e,r,l,k)};this.intersect=function(b,d,c,q,e,l,k,w){if(null!=a.verticalOffset){w=
q.camera;g.set3(c[12],c[13],c[14],J);var m=g.subtract(J,w.eye,Z),O=g.length(m),h=g.scale(m,1/O),r=null,m=null;switch(q.viewingMode){case "global":m=g.normalize(J,N);break;case "local":m=g.set(Y,N)}a.screenSizePerspective&&(r=g.dot(m,h));w=f.verticalOffsetAtDistance(w,O,a.verticalOffset,r,a.screenSizePerspective);g.scale(m,w);M.multiplyVec3(q.transformInverseRotation,m,I);e=g.subtract(e,I,W);l=g.subtract(l,I,X)}f.intersectTriangleGeometry(b,d,c,q,e,l,k)};this.getGLMaterials=function(){return{color:aa,
depthShadowMap:a.castShadows?ba:null,normal:ca,depth:P,highlight:da}};this.getAllTextureIds=function(){var b=[];return a.textureId&&b.push(a.textureId),a.reflTextureId&&b.push(a.reflTextureId),b}};v.paramsFromOldConstructor=function(a,c,e,b,d,h,f,m,q,r,l,k,g){return{textureId:a,transparent:c,ambient:e,diffuse:b,specular:d,shininess:h,opacity:f,polygonOffset:m,initTexture:q,reflTextureId:r,reflectivity:l,flipV:k,doubleSided:g,cullFace:void 0}};var C=function(a,c){var e=a.gl;(c.cullFace?"none"===c.cullFace:
c.transparent)?a.setFaceCullingEnabled(!1):(a.setFaceCullingEnabled(!0),"front"===c.cullFace&&a.setCullFace(e.FRONT))},D=function(a,c){var e=a.gl;(c.cullFace?"none"===c.cullFace:c.transparent)?a.setFaceCullingEnabled(!0):(a.setFaceCullingEnabled(!1),"front"===c.cullFace&&a.setCullFace(e.BACK))},x=function(a,c){return a?E.TRANSPARENT_MATERIAL:c?E.STENCIL_MATERIAL:E.OPAQUE_MATERIAL},aa=function(a,c,e){f.basicGLMaterialConstructor(this,a);var b=f.copyParameters(a.getParams()),d=x(b.transparent,b.writeStencil);
f.singleTextureGLMaterialConstructor(this,e,b);var h=f.aquireIfNotUndefined(b.reflTextureId,b.reflInitTexture,e);h&&(h=h.getGLTexture());H(!(b.atlasRegions&&b.reflTextureId),"Atlas texture with reflection is not yet supported");var g=b.textureId?b.atlasRegions?"AtlasTextured":"Textured":"none";this.instanced=u&&b.instanced;var m,q=!!this.instanced&&-1<this.instanced.indexOf("color"),r=!u&&b.instanced&&-1<b.instanced.indexOf("color"),l=[[null,null],[null,null]],k=null;this._loadPrograms=function(){l[0][0]=
this._loadProgram(!1,!1);l[1][0]=this._loadProgram(!0,!1);b.receiveSSAO?(l[0][1]=this._loadProgram(!1,!0),l[1][1]=this._loadProgram(!0,!0),m=l[0].concat(l[1])):(l[0][1]=l[0][0],l[1][1]=l[1][0],m=[l[0][0],l[1][0]])};this._loadProgram=function(a,d){return c.getShaderVariationsProgram("material",[g,!!b.reflTextureId,b.vertexColors,b.symbolColors,b.flipV,b.doubleSided,!!this.instanced,q,a,d,!!b.vvSizeEnabled,!!b.vvColorEnabled,null!=b.verticalOffset,null!=b.screenSizePerspective,b.groundNormalShading])};
this._loadPrograms();var n="AtlasTextured"===g,p=this.dispose;this.dispose=function(){p();f.releaseIfNotUndefined(b.reflTextureId,e)};this.beginSlot=function(a){return d===a};this.getProgram=function(){return k||l[0][0]};this.getAllPrograms=function(){return m};this.updateParameters=function(){var c=a.getParams();b.ambient=c.ambient;b.diffuse=c.diffuse;b.specular=c.specular;b.externalColor=c.externalColor;b.colorMixMode=c.colorMixMode;b.shininess=c.shininess;b.opacity=c.opacity;b.layerOpacity=c.layerOpacity;
b.polygonOffset=c.polygonOffset;b.reflectivity=c.reflectivity;b.flipV=c.flipV;b.doubleSided=c.doubleSided;b.cullFace=c.cullFace;b.receiveSSAO=c.receiveSSAO;b.castShadows=c.castShadows;b.verticalOffset=c.verticalOffset;b.screenSizePerspective=c.screenSizePerspective;B(b,c);b.vvColorEnabled=c.vvColorEnabled;b.vvColorValues=c.vvColorValues;b.vvColorColors=c.vvColorColors;b.transparent!=c.transparent&&(d=x(c.transparent),b.transparent=c.transparent);b.groundNormalShading=c.groundNormalShading;b.initTexture=
c.initTexture;this.updateTexture(c.textureId);c.atlasRegions&&(b.atlasRegions=c.atlasRegions);b.blendModeOneOne=c.blendModeOneOne;b.inverseWindingOrder=c.inverseWindingOrder;this._loadPrograms()};this.bind=function(a,d){var c=a.gl;k=l[d.shadowMappingEnabled?1:0][d.ssaoEnabled?1:0];a.bindProgram(k);k.setUniform3fv("ambient",b.ambient);k.setUniform3fv("diffuse",b.diffuse);k.setUniform3fv("specular",b.specular);k.setUniform4fv("externalColor",b.externalColor);k.setUniform1i("colorMixMode",f.colorMixModes[b.colorMixMode]);
k.setUniform1f("shininess",b.shininess);k.setUniform1f("opacity",b.opacity);k.setUniform1f("layerOpacity",b.layerOpacity);f.bindVerticalOffset(b.verticalOffset,d,k);f.bindScreenSizePerspective(b.screenSizePerspective,k);A(k,b);this.bindTexture(a,k);n&&this.bindTextureSize(a,k);a.setBlendFunctionSeparate(c.SRC_ALPHA,c.ONE_MINUS_SRC_ALPHA,c.ONE,c.ONE_MINUS_SRC_ALPHA);void 0!==h&&(k.setUniform1i("reflTex",1),a.bindTexture(h,1),k.setUniform1f("reflectivity",b.reflectivity));b.inverseWindingOrder&&a.setFrontFace(c.CW);
b.transparent?(a.setBlendingEnabled(!0),b.blendModeOneOne?(a.setBlendFunction(c.ONE,c.ONE),a.setDepthWriteEnabled(!1)):a.setBlendFunctionSeparate(c.SRC_ALPHA,c.ONE_MINUS_SRC_ALPHA,c.ONE,c.ONE_MINUS_SRC_ALPHA)):a.setBlendingEnabled(!1);b.polygonOffset&&(a.setPolygonOffsetFillEnabled(!0),a.setPolygonOffset(2,2));C(a,b);a.setDepthTestEnabled(!0)};this.release=function(a,c){c=a.gl;a.setPolygonOffsetFillEnabled(!1);D(a,b);a.setBlendingEnabled(!1);a.setBlendFunctionSeparate(c.SRC_ALPHA,c.ONE_MINUS_SRC_ALPHA,
c.ONE,c.ONE_MINUS_SRC_ALPHA);a.setDepthWriteEnabled(!0);a.setFrontFace(c.CCW)};this.bindView=function(a,b){k=l[b.shadowMappingEnabled?1:0][b.ssaoEnabled?1:0];a=b.origin;f.bindView(a,b.view,k);f.bindCamPos(a,b.viewInvTransp,k);b.shadowMappingEnabled&&b.shadowMap.bindView(k,a)};this.bindInstance=function(a,c){(k.setUniformMatrix4fv("model",c.transformation),k.setUniformMatrix4fv("modelNormal",c.transformationNormal),c.instanceParameters&&r)&&(a=c.instanceParameters.color)&&k.setUniform4fv("externalColor",
V(a,b.externalColor))};this.getDrawMode=function(a){return a.gl.TRIANGLES}},P=function(a,c,e,b){f.basicGLMaterialConstructor(this,a);var d=f.copyParameters(a.getParams());this.instanced=u&&d.instanced;var h=t.hasAttribute(a.getVertexBufferLayout(),"uv0")?(d.atlasRegions,"Textured"):"none",g=c.getShaderVariationsProgram("material-depth",[h,d.flipV,!!this.instanced,!!b,!!d.vvSizeEnabled,null!=d.verticalOffset,null!=d.screenSizePerspective]),m=x(d.transparent,d.writeStencil);f.singleTextureGLMaterialConstructor(this,
e,d);this.beginSlot=function(a){return m===a};this.getProgram=function(){return g};this.updateParameters=function(){var b=a.getParams();d.initTexture=b.initTexture;d.cullFace=b.cullFace;d.inverseWindingOrder=b.inverseWindingOrder;d.flipV=b.flipV;B(d,b);this.updateTexture(b.textureId)};this.bind=function(a,b){var c=a.gl;a.bindProgram(g);g.setUniform2fv("nearFar",b.nearFar);d.inverseWindingOrder&&a.setFrontFace(c.CW);f.bindVerticalOffset(d.verticalOffset,b,g);f.bindScreenSizePerspective(d.screenSizePerspective,
g);A(g,d);this.bindTexture(a,g);C(a,d);a.setDepthTestEnabled(!0)};this.release=function(a){var b=a.gl;D(a,d);d.inverseWindingOrder&&a.setFrontFace(b.CCW)};this.bindView=function(a,b){f.bindView(b.origin,b.view,g);d.screenSizePerspective&&f.bindCamPos(b.origin,b.viewInvTransp,g)};this.bindInstance=function(a,b){g.setUniformMatrix4fv("model",b.transformation)};this.getDrawMode=function(a){return a.gl.TRIANGLES}},ba=function(a,c,e){P.call(this,a,c,e,!0)},ca=function(a,c,e){f.basicGLMaterialConstructor(this,
a);var b=f.copyParameters(a.getParams()),d=t.hasAttribute(a.getVertexBufferLayout(),"uv0")?(b.atlasRegions,"Textured"):"none";this.instanced=u&&b.instanced;var h=c.getShaderVariationsProgram("material-normal",[d,b.flipV,!!this.instanced,!!b.vvSizeEnabled,null!=b.verticalOffset,null!=b.screenSizePerspective]),g=x(b.transparent,b.writeStencil);f.singleTextureGLMaterialConstructor(this,e,b);this.beginSlot=function(a){return g===a};this.getProgram=function(){return h};this.updateParameters=function(){var c=
a.getParams();b.initTexture=c.initTexture;b.cullFace=c.cullFace;b.inverseWindingOrder=c.inverseWindingOrder;b.flipV=c.flipV;B(b,c);this.updateTexture(c.textureId)};this.bind=function(a,c){var d=a.gl;a.bindProgram(h);this.bindTexture(a,h);h.setUniformMatrix4fv("viewNormal",c.viewInvTransp);f.bindVerticalOffset(b.verticalOffset,c,h);f.bindScreenSizePerspective(b.screenSizePerspective,h);A(h,b);C(a,b);b.inverseWindingOrder&&a.setFrontFace(d.CW);a.setDepthTestEnabled(!0)};this.release=function(a){var c=
a.gl;D(a,b);b.inverseWindingOrder&&a.setFrontFace(c.CCW)};this.bindView=function(a,c){f.bindView(c.origin,c.view,h);b.screenSizePerspective&&f.bindCamPos(c.origin,c.viewInvTransp,h)};this.bindInstance=function(a,b){h.setUniformMatrix4fv("model",b.transformation);h.setUniformMatrix4fv("modelNormal",b.transformationNormal)};this.getDrawMode=function(a){return a.gl.TRIANGLES}},da=function(a,c,e,b){f.basicGLMaterialConstructor(this,a);var d=f.copyParameters(a.getParams());b=t.hasAttribute(a.getVertexBufferLayout(),
"uv0")?(d.atlasRegions,"Textured"):"none";this.instanced=u&&d.instanced;var h=c.getShaderVariationsProgram("material-highlight",[b,d.flipV,!!this.instanced,!!d.vvSizeEnabled,null!=d.verticalOffset,null!=d.screenSizePerspective]),g=x(d.transparent,d.writeStencil);f.singleTextureGLMaterialConstructor(this,e,d);this.beginSlot=function(a){return g===a};this.getProgram=function(){return h};this.updateParameters=function(){var b=a.getParams();d.initTexture=b.initTexture;d.cullFace=b.cullFace;d.inverseWindingOrder=
b.inverseWindingOrder;d.flipV=b.flipV;B(d,b);this.updateTexture(b.textureId)};this.bind=function(a,b){var c=a.gl;a.bindProgram(h);this.bindTexture(a,h);f.bindVerticalOffset(d.verticalOffset,b,h);f.bindScreenSizePerspective(d.screenSizePerspective,h);A(h,d);C(a,d);d.inverseWindingOrder&&a.setFrontFace(c.CW);a.setDepthTestEnabled(!0)};this.release=function(a){var b=a.gl;D(a,d);d.inverseWindingOrder&&a.setFrontFace(b.CW)};this.bindView=function(a,b){f.bindView(b.origin,b.view,h);d.screenSizePerspective&&
f.bindCamPos(b.origin,b.viewInvTransp,h)};this.bindInstance=function(a,b){h.setUniformMatrix4fv("model",b.transformation);h.setUniformMatrix4fv("modelNormal",b.transformationNormal)};this.getDrawMode=function(a){return a.gl.TRIANGLES}};return v.getVertexBufferLayout=function(a){var c="Pos3";return a.groundNormalShading||(c+="Norm"),a.textureId&&(c+=a.atlasRegions?"TexRegion":"Tex"),a.vertexColors&&(c+="Col"),a.symbolColors&&(c+="Symcol"),S[c]},v.loadShaders=function(a,c,e,b){a._parse(Q);u=b.extensions.angleInstancedArrays;
b.extensions.shaderTextureLOD;b.extensions.standardDerivatives;var d=new y("phong",["vsPhong","fsPhong"],null,e,c,a,b);d.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},{value:"AtlasTextured"}]);d.addBinaryShaderSnippetSuffix("Refl","Refl",[!1,!0]);d.addDefine("Color","VERTEXCOLORS");d.addDefine("symbolColor","SYMBOLVERTEXCOLORS");d.addDefine("FlipV","FLIPV");d.addDefine("DoubleSided","DOUBLESIDED");d.addDefine("Instanced","INSTANCED");d.addDefine("InstColor",
"INSTANCEDCOLOR");d.addDefine("ReceiveShadows","RECEIVE_SHADOWS");d.addDefine("ReceiveSSAO","RECEIVE_SSAO");d.addDefine("vvSize","VV_SIZE");d.addDefine("vvColor","VV_COLOR");d.addDefine("VerticalOffset","VERTICAL_OFFSET");d.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");d.addDefine("groundNormalShading","GROUND_NORMAL_SHADING");e.addShaderVariations("material",d);d=new y("depth",["vsDepth","fsDepth"],null,e,c,a,b);d.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},
{value:"Textured"},{value:"AtlasTextured"}]);d.addDefine("FlipV","FLIPV");d.addDefine("Instanced","INSTANCED");d.addDefine("ShadowMap","BIAS_SHADOWMAP");d.addDefine("vvSize","VV_SIZE");d.addDefine("VerticalOffset","VERTICAL_OFFSET");d.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");e.addShaderVariations("material-depth",d);d=new y("normal",["vsNormal","fsNormal"],null,e,c,a,b);d.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},
{value:"AtlasTextured"}]);d.addDefine("FlipV","FLIPV");d.addDefine("Instanced","INSTANCED");d.addDefine("vvSize","VV_SIZE");d.addDefine("VerticalOffset","VERTICAL_OFFSET");d.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");e.addShaderVariations("material-normal",d);d=new y("highlight",["vsHighlight","fsHighlight"],null,e,c,a,b);d.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},{value:"AtlasTextured"}]);d.addDefine("FlipV","FLIPV");
d.addDefine("Instanced","INSTANCED");d.addDefine("vvSize","VV_SIZE");d.addDefine("VerticalOffset","VERTICAL_OFFSET");d.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");e.addShaderVariations("material-highlight",d);var d=new n(b,a.vsDepth,a.fsDepth,p.Default3D,["BIAS_SHADOWMAP 1"]),f=new n(b,a.vsDepthTextured,a.fsDepthTextured,p.Default3D,["BIAS_SHADOWMAP 1"]),g=new n(b,a.vsDepth,a.fsDepth,p.Default3D),m=new n(b,a.vsDepthTextured,a.fsDepthTextured,p.Default3D),q=new n(b,a.vsNormal,a.fsNormal,
p.Default3D),r=new n(b,a.vsNormalTextured,a.fsNormalTextured,p.Default3D),l=new n(b,a.vsHighlight,a.fsHighlight,p.Default3D);b=new n(b,a.vsHighlightTextured,a.fsHighlightTextured,p.Default3D);e.add("depthShadowMap",d);e.add("depthTexturedShadowMap",f);e.add("depth",g);e.add("depthTextured",m);e.add("normal",q);e.add("normalTextured",r);e.add("highlight",l);e.add("highlightTextured",b);c.add("fsDepth",{source:a.fsDepth});c.add("fsDepthTextured",{source:a.fsDepthTextured});c.add("fsDepthShadowMap",
{source:a.fsDepthShadowMap,defines:["BIAS_SHADOWMAP 1"]});c.add("fsDepthTexturedShadowMap",{source:a.fsDepthTextured,defines:["BIAS_SHADOWMAP 1"]});c.add("vsDepth",{source:a.vsDepth});c.add("fsNormal",{source:a.fsNormal})},v});